{"ast":null,"code":"import isEqual from 'fast-deep-equal/es6';\nimport React, { useRef, useState, useEffect, useContext } from 'react';\nimport produce$1, { enablePatches, produceWithPatches, produce, applyPatches } from 'immer';\n\nfunction useStoreState(store, getSubState, deps) {\n  const updateRef = useRef({\n    state: undefined,\n    initialized: false\n  });\n\n  if (!updateRef.current.initialized) {\n    updateRef.current.state = getSubState ? getSubState(store.getRawState()) : store.getRawState();\n    updateRef.current.initialized = true;\n  }\n\n  const [, setUpdateTrigger] = useState(0);\n  useEffect(() => {\n    const effectState = {\n      shouldUpdate: true\n    };\n\n    function update() {\n      if (effectState.shouldUpdate) {\n        const nextSubState = getSubState ? getSubState(store.getRawState()) : store.getRawState();\n\n        if (!isEqual(updateRef.current.state, nextSubState)) {\n          if (effectState.shouldUpdate) {\n            updateRef.current.state = nextSubState;\n            setUpdateTrigger(val => val + 1);\n          }\n        }\n      }\n    }\n\n    store._addUpdateListener(update);\n\n    update();\n    return () => {\n      effectState.shouldUpdate = false;\n\n      store._removeUpdateListener(update);\n    };\n  }, deps !== null && deps !== void 0 ? deps : []);\n\n  if (deps !== undefined) {\n    const prevDeps = useRef(deps);\n\n    if (!isEqual(deps, prevDeps)) {\n      updateRef.current.state = getSubState(store.getRawState());\n    }\n  }\n\n  return updateRef.current.state;\n}\n\nlet updateListenerOrd = 0;\n\nfunction fastGet(obj, path) {\n  return path.reduce((cur = obj, key) => {\n    return cur[key];\n  }, undefined);\n}\n\nfunction getSubStateFromPaths(store, paths) {\n  const state = store.getRawState();\n  const resp = [];\n\n  for (const path of paths) {\n    resp.push(fastGet(state, path));\n  }\n\n  return resp;\n}\n\nfunction useStoreStateOpt(store, paths) {\n  const [subState, setSubState] = useState(() => getSubStateFromPaths(store, paths));\n  const updateRef = useRef({\n    shouldUpdate: true,\n    onStoreUpdate: null,\n    currentSubState: null,\n    ordKey: `_${updateListenerOrd++}`\n  });\n  updateRef.current.currentSubState = subState;\n\n  if (updateRef.current.onStoreUpdate === null) {\n    updateRef.current.onStoreUpdate = function onStoreUpdateOpt() {\n      if (updateRef.current.shouldUpdate) {\n        setSubState(getSubStateFromPaths(store, paths));\n      }\n    };\n\n    store._addUpdateListenerOpt(updateRef.current.onStoreUpdate, updateRef.current.ordKey, paths);\n  }\n\n  useEffect(() => () => {\n    updateRef.current.shouldUpdate = false;\n\n    store._removeUpdateListenerOpt(updateRef.current.ordKey);\n  }, []);\n  return subState;\n}\n\nfunction useLocalStore(initialState, deps) {\n  const storeRef = useRef();\n\n  if (storeRef.current == null) {\n    storeRef.current = new Store(initialState);\n  }\n\n  if (deps !== undefined) {\n    const prevDeps = useRef(deps);\n\n    if (!isEqual(deps, prevDeps)) {\n      storeRef.current = new Store(initialState);\n    }\n  }\n\n  return storeRef.current;\n}\n\nconst globalClientState = {\n  storeOrdinal: 0,\n  batching: false,\n  flushStores: {}\n};\nenablePatches();\n\nfunction makeSubscriptionFunction(store, watch, listener) {\n  let lastWatchState = watch(store.getRawState());\n  return () => {\n    const currentState = store.getRawState();\n    const nextWatchState = watch(currentState);\n\n    if (!isEqual(nextWatchState, lastWatchState)) {\n      listener(nextWatchState, currentState, lastWatchState);\n      lastWatchState = nextWatchState;\n    }\n  };\n}\n\nfunction makeReactionFunctionCreator(watch, reaction) {\n  return store => {\n    let lastWatchState = watch(store.getRawState());\n    return (forceRun = false) => {\n      const currentState = store.getRawState();\n      const nextWatchState = watch(currentState);\n\n      if (forceRun || !isEqual(nextWatchState, lastWatchState)) {\n        if (store._optListenerCount > 0) {\n          const [nextState, patches, inversePatches] = produceWithPatches(currentState, s => reaction(nextWatchState, s, currentState, lastWatchState));\n\n          store._updateStateWithoutReaction(nextState);\n\n          lastWatchState = nextWatchState;\n\n          if (patches.length > 0) {\n            store._patchListeners.forEach(listener => listener(patches, inversePatches));\n\n            return Object.keys(getChangedPathsFromPatches(patches));\n          }\n        } else {\n          if (store._patchListeners.length > 0) {\n            const [nextState, patches, inversePatches] = produceWithPatches(currentState, s => reaction(nextWatchState, s, currentState, lastWatchState));\n\n            if (patches.length > 0) {\n              store._patchListeners.forEach(listener => listener(patches, inversePatches));\n            }\n\n            store._updateStateWithoutReaction(nextState);\n          } else {\n            store._updateStateWithoutReaction(produce(currentState, s => reaction(nextWatchState, s, currentState, lastWatchState)));\n          }\n\n          lastWatchState = nextWatchState;\n        }\n      }\n\n      return [];\n    };\n  };\n}\n\nconst optPathDivider = \"~._.~\";\n\nclass Store {\n  constructor(initialState) {\n    this.updateListeners = [];\n    this.ssr = false;\n    this.reactions = [];\n    this.clientSubscriptions = [];\n    this.reactionCreators = [];\n    this.optimizedUpdateListeners = {};\n    this.optimizedUpdateListenerPaths = {};\n    this.optimizedListenerPropertyMap = {};\n    this._optListenerCount = 0;\n    this._patchListeners = [];\n\n    if (initialState instanceof Function) {\n      const state = initialState();\n      this.currentState = state;\n      this.initialState = state;\n      this.createInitialState = initialState;\n    } else {\n      this.currentState = initialState;\n      this.initialState = initialState;\n\n      this.createInitialState = () => initialState;\n    }\n\n    this.internalOrdId = globalClientState.storeOrdinal++;\n  }\n\n  _setInternalOptions({\n    ssr,\n    reactionCreators = []\n  }) {\n    this.ssr = ssr;\n    this.reactionCreators = reactionCreators;\n    this.reactions = reactionCreators.map(rc => rc(this));\n  }\n\n  _getReactionCreators() {\n    return this.reactionCreators;\n  }\n\n  _instantiateReactions() {\n    this.reactions = this.reactionCreators.map(rc => rc(this));\n  }\n\n  _getInitialState() {\n    return this.createInitialState();\n  }\n\n  _updateStateWithoutReaction(nextState) {\n    this.currentState = nextState;\n  }\n\n  _updateState(nextState, updateKeyedPaths = []) {\n    this.currentState = nextState;\n    this.batchState = undefined;\n\n    for (const runReaction of this.reactions) {\n      updateKeyedPaths.push(...runReaction());\n    }\n\n    if (!this.ssr) {\n      for (const runSubscription of this.clientSubscriptions) {\n        runSubscription();\n      }\n\n      if (updateKeyedPaths.length > 0) {\n        const updateOrds = new Set();\n\n        for (const keyedPath of updateKeyedPaths) {\n          if (this.optimizedListenerPropertyMap[keyedPath]) {\n            for (const ord of this.optimizedListenerPropertyMap[keyedPath]) {\n              updateOrds.add(ord);\n            }\n          }\n        }\n\n        for (const ord of updateOrds.values()) {\n          if (this.optimizedUpdateListeners[ord]) {\n            this.optimizedUpdateListeners[ord]();\n          }\n        }\n      }\n\n      this.updateListeners.forEach(listener => listener());\n    }\n  }\n\n  _addUpdateListener(listener) {\n    this.updateListeners.push(listener);\n  }\n\n  _addUpdateListenerOpt(listener, ordKey, paths) {\n    this.optimizedUpdateListeners[ordKey] = listener;\n    const listenerPathsKeyed = paths.map(path => path.join(optPathDivider));\n    this.optimizedUpdateListenerPaths[ordKey] = listenerPathsKeyed;\n\n    for (const keyedPath of listenerPathsKeyed) {\n      if (this.optimizedListenerPropertyMap[keyedPath] == null) {\n        this.optimizedListenerPropertyMap[keyedPath] = [ordKey];\n      } else {\n        this.optimizedListenerPropertyMap[keyedPath].push(ordKey);\n      }\n    }\n\n    this._optListenerCount++;\n  }\n\n  _removeUpdateListener(listener) {\n    this.updateListeners = this.updateListeners.filter(f => f !== listener);\n  }\n\n  _removeUpdateListenerOpt(ordKey) {\n    const listenerPathsKeyed = this.optimizedUpdateListenerPaths[ordKey];\n\n    for (const keyedPath of listenerPathsKeyed) {\n      this.optimizedListenerPropertyMap[keyedPath] = this.optimizedListenerPropertyMap[keyedPath].filter(ord => ord !== ordKey);\n    }\n\n    delete this.optimizedUpdateListenerPaths[ordKey];\n    delete this.optimizedUpdateListeners[ordKey];\n    this._optListenerCount--;\n  }\n\n  listenToPatches(patchListener) {\n    this._patchListeners.push(patchListener);\n\n    return () => {\n      this._patchListeners = this._patchListeners.filter(f => f !== patchListener);\n    };\n  }\n\n  subscribe(watch, listener) {\n    if (!this.ssr) {\n      const func = makeSubscriptionFunction(this, watch, listener);\n      this.clientSubscriptions.push(func);\n      return () => {\n        this.clientSubscriptions = this.clientSubscriptions.filter(f => f !== func);\n      };\n    }\n\n    return () => {\n      console.warn(`Pullstate: Subscriptions made on the server side are not registered - so therefor this call to unsubscribe does nothing.`);\n    };\n  }\n\n  createReaction(watch, reaction, {\n    runNow = false,\n    runNowWithSideEffects = false\n  } = {}) {\n    const creator = makeReactionFunctionCreator(watch, reaction);\n    this.reactionCreators.push(creator);\n    const func = creator(this);\n    this.reactions.push(func);\n\n    if (runNow || runNowWithSideEffects) {\n      func(true);\n\n      if (runNowWithSideEffects && !this.ssr) {\n        this._updateState(this.currentState);\n      }\n    }\n\n    return () => {\n      this.reactions = this.reactions.filter(f => f !== func);\n    };\n  }\n\n  getRawState() {\n    if (this.batchState !== undefined) {\n      return this.batchState;\n    } else {\n      return this.currentState;\n    }\n  }\n\n  useState(getSubState, deps) {\n    return useStoreState(this, getSubState, deps);\n  }\n\n  useLocalCopyInitial(deps) {\n    return useLocalStore(this.createInitialState, deps);\n  }\n\n  useLocalCopySnapshot(deps) {\n    return useLocalStore(this.currentState, deps);\n  }\n\n  flushBatch(ignoreError = false) {\n    if (this.batchState !== undefined) {\n      if (this.batchState !== this.currentState) {\n        this._updateState(this.batchState);\n      }\n    } else if (!ignoreError) {\n      console.error(`Pullstate: Trying to flush batch state which was never created or updated on`);\n    }\n\n    this.batchState = undefined;\n  }\n\n  update(updater, patchesCallback) {\n    if (globalClientState.batching) {\n      if (this.batchState === undefined) {\n        this.batchState = this.currentState;\n        globalClientState.flushStores[this.internalOrdId] = this;\n      }\n\n      const func = typeof updater === \"function\";\n      const [nextState, patches, inversePatches] = runUpdates(this.batchState, updater, func);\n\n      if (patches.length > 0 && (this._patchListeners.length > 0 || patchesCallback)) {\n        if (patchesCallback) {\n          patchesCallback(patches, inversePatches);\n        }\n\n        this._patchListeners.forEach(listener => listener(patches, inversePatches));\n      }\n\n      this.batchState = nextState;\n    } else {\n      this.batchState = undefined;\n      update(this, updater, patchesCallback);\n    }\n  }\n\n  replace(newState) {\n    this._updateState(newState);\n  }\n\n  applyPatches(patches) {\n    applyPatchesToStore(this, patches);\n  }\n\n}\n\nfunction applyPatchesToStore(store, patches) {\n  const currentState = store.getRawState();\n  const nextState = applyPatches(currentState, patches);\n\n  if (nextState !== currentState) {\n    store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));\n  }\n}\n\nfunction getChangedPathsFromPatches(changePatches, prev = {}) {\n  for (const patch of changePatches) {\n    let curKey;\n\n    for (const p of patch.path) {\n      if (curKey) {\n        curKey = `${curKey}${optPathDivider}${p}`;\n      } else {\n        curKey = p;\n      }\n\n      prev[curKey] = 1;\n    }\n  }\n\n  return prev;\n}\n\nfunction runUpdates(currentState, updater, func) {\n  return func ? produceWithPatches(currentState, s => updater(s, currentState)) : updater.reduce(([nextState, patches, inversePatches], currentValue) => {\n    const resp = produceWithPatches(nextState, s => currentValue(s, nextState));\n    patches.push(...resp[1]);\n    inversePatches.push(...resp[2]);\n    return [resp[0], patches, inversePatches];\n  }, [currentState, [], []]);\n}\n\nfunction update(store, updater, patchesCallback) {\n  const currentState = store.getRawState();\n  const func = typeof updater === \"function\";\n\n  if (store._optListenerCount > 0) {\n    const [nextState, patches, inversePatches] = runUpdates(currentState, updater, func);\n\n    if (patches.length > 0) {\n      if (patchesCallback) {\n        patchesCallback(patches, inversePatches);\n      }\n\n      store._patchListeners.forEach(listener => listener(patches, inversePatches));\n\n      store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));\n    }\n  } else {\n    let nextState;\n\n    if (store._patchListeners.length > 0 || patchesCallback) {\n      const [ns, patches, inversePatches] = runUpdates(currentState, updater, func);\n\n      if (patches.length > 0) {\n        if (patchesCallback) {\n          patchesCallback(patches, inversePatches);\n        }\n\n        store._patchListeners.forEach(listener => listener(patches, inversePatches));\n      }\n\n      nextState = ns;\n    } else {\n      nextState = produce(currentState, s => func ? updater(s, currentState) : updater.reduce((previousValue, currentUpdater) => {\n        return produce(previousValue, s => currentUpdater(s, previousValue));\n      }, currentState));\n    }\n\n    if (nextState !== currentState) {\n      store._updateState(nextState);\n    }\n  }\n}\n\nfunction InjectStoreState({\n  store,\n  on = s => s,\n  children\n}) {\n  const state = useStoreState(store, on);\n  return children(state);\n}\n\nvar EAsyncEndTags;\n\n(function (EAsyncEndTags) {\n  EAsyncEndTags[\"THREW_ERROR\"] = \"THREW_ERROR\";\n  EAsyncEndTags[\"RETURNED_ERROR\"] = \"RETURNED_ERROR\";\n  EAsyncEndTags[\"UNFINISHED\"] = \"UNFINISHED\";\n  EAsyncEndTags[\"DORMANT\"] = \"DORMANT\";\n})(EAsyncEndTags || (EAsyncEndTags = {}));\n\nvar EPostActionContext;\n\n(function (EPostActionContext) {\n  EPostActionContext[\"WATCH_HIT_CACHE\"] = \"WATCH_HIT_CACHE\";\n  EPostActionContext[\"BECKON_HIT_CACHE\"] = \"BECKON_HIT_CACHE\";\n  EPostActionContext[\"RUN_HIT_CACHE\"] = \"RUN_HIT_CACHE\";\n  EPostActionContext[\"READ_HIT_CACHE\"] = \"READ_HIT_CACHE\";\n  EPostActionContext[\"READ_RUN\"] = \"READ_RUN\";\n  EPostActionContext[\"SHORT_CIRCUIT\"] = \"SHORT_CIRCUIT\";\n  EPostActionContext[\"DIRECT_RUN\"] = \"DIRECT_RUN\";\n  EPostActionContext[\"BECKON_RUN\"] = \"BECKON_RUN\";\n  EPostActionContext[\"CACHE_UPDATE\"] = \"CACHE_UPDATE\";\n})(EPostActionContext || (EPostActionContext = {}));\n\nconst clientAsyncCache = {\n  listeners: {},\n  results: {},\n  actions: {},\n  actionOrd: {}\n};\nlet asyncCreationOrdinal = 0;\n\nfunction keyFromObject(json) {\n  if (json === null) {\n    return \"(n)\";\n  }\n\n  const typeOf = typeof json;\n\n  if (typeOf !== \"object\") {\n    if (typeOf === \"undefined\") {\n      return \"(u)\";\n    } else if (typeOf === \"string\") {\n      return \":\" + json + \";\";\n    } else if (typeOf === \"boolean\" || typeOf === \"number\") {\n      return \"(\" + json + \")\";\n    }\n  }\n\n  let prefix = \"{\";\n\n  for (const key of Object.keys(json).sort()) {\n    prefix += key + keyFromObject(json[key]);\n  }\n\n  return prefix + \"}\";\n}\n\nfunction notifyListeners(key) {\n  if (clientAsyncCache.listeners.hasOwnProperty(key)) {\n    for (const watchId of Object.keys(clientAsyncCache.listeners[key])) {\n      clientAsyncCache.listeners[key][watchId]();\n    }\n  }\n}\n\nfunction clearActionCache(key, clearPending = true, notify = true) {\n  if (clearPending && clientAsyncCache.actionOrd.hasOwnProperty(key)) {\n    clientAsyncCache.actionOrd[key] += 1;\n  }\n\n  delete clientAsyncCache.results[key];\n\n  if (notify) {\n    notifyListeners(key);\n  }\n}\n\nfunction actionOrdUpdate(cache, key) {\n  if (!cache.actionOrd.hasOwnProperty(key)) {\n    cache.actionOrd[key] = 0;\n  } else {\n    cache.actionOrd[key] += 1;\n  }\n\n  return cache.actionOrd[key];\n}\n\nfunction successResult(payload = null, tags = [], message = \"\") {\n  return {\n    payload,\n    tags,\n    message,\n    error: false,\n    errorPayload: null\n  };\n}\n\nfunction errorResult(tags = [], message = \"\", errorPayload) {\n  return {\n    payload: null,\n    tags: [EAsyncEndTags.RETURNED_ERROR, ...tags],\n    message,\n    error: true,\n    errorPayload: errorPayload\n  };\n}\n\nclass PullstateAsyncError extends Error {\n  constructor(message, tags) {\n    super(message);\n    this.tags = tags;\n  }\n\n}\n\nlet storeErrorProxy;\n\ntry {\n  storeErrorProxy = new Proxy({}, {\n    get: function (obj, prop) {\n      throw new Error(`Pullstate: Trying to access store (${String(prop)}) inside async actions without the correct usage or setup.\nIf this error occurred on the server:\n* If using run(), make use of your created instance for this request: instance.runAsyncAction()\n* If using read(), useWatch(), useBeckon() etc. - make sure you have properly set up your <PullstateProvider/>\n\nIf this error occurred on the client:\n* Make sure you have created your \"pullstateCore\" object with all your stores, using createPullstateCore(), and are making use of instantiate() before rendering.`);\n    }\n  });\n} catch {\n  storeErrorProxy = {};\n}\n\nconst startedButUnfinishedResult = [true, false, {\n  message: \"\",\n  tags: [EAsyncEndTags.UNFINISHED],\n  error: true,\n  payload: null,\n  errorPayload: null\n}, false, -1];\n\nfunction createAsyncActionDirect(action, options = {}) {\n  return createAsyncAction(async (args, stores, customContext) => {\n    return successResult(await action(args, stores, customContext));\n  }, options);\n}\n\nfunction createAsyncAction(action, {\n  forceContext = false,\n  shortCircuitHook,\n  cacheBreakHook,\n  postActionHook,\n  subsetKey,\n  actionId\n} = {}) {\n  const ordinal = actionId != null ? `_${actionId}` : asyncCreationOrdinal++;\n  const onServer = typeof window === \"undefined\";\n\n  function _createKey(args, customKey) {\n    if (customKey != null) {\n      return `${ordinal}-c-${customKey}`;\n    }\n\n    if (subsetKey !== undefined) {\n      return `${ordinal}-${keyFromObject(subsetKey(args))}`;\n    }\n\n    return `${ordinal}-${keyFromObject(args)}`;\n  }\n\n  const deferWaitingKey = `def_wait_${_createKey({})}`;\n  let cacheBreakWatcher = {};\n  let watchIdOrd = 0;\n  const shouldUpdate = {};\n\n  function runPostActionHook(result, args, stores, context) {\n    if (postActionHook !== undefined) {\n      postActionHook({\n        args,\n        result,\n        stores,\n        context\n      });\n    }\n  }\n\n  function getCachedResult({\n    args,\n    cache,\n    cacheBreakEnabled,\n    context,\n    fromListener,\n    key,\n    postActionEnabled,\n    stores,\n    customCacheBreak\n  }) {\n    const useCacheBreakHook = customCacheBreak !== null && customCacheBreak !== void 0 ? customCacheBreak : cacheBreakHook;\n\n    if (cache.results.hasOwnProperty(key)) {\n      const cacheBreakLoop = cacheBreakWatcher.hasOwnProperty(key) && cacheBreakWatcher[key] > 2;\n\n      if (!onServer && !fromListener && cacheBreakEnabled && useCacheBreakHook != null && cache.results[key][1] && useCacheBreakHook({\n        args,\n        result: cache.results[key][2],\n        stores,\n        timeCached: cache.results[key][4]\n      }) && !cacheBreakLoop) {\n        if (cacheBreakWatcher.hasOwnProperty(key)) {\n          cacheBreakWatcher[key]++;\n        } else {\n          cacheBreakWatcher[key] = 1;\n        }\n\n        const previous = cache.results[key];\n        delete cache.results[key];\n        return {\n          cacheBroke: true,\n          response: undefined,\n          previous\n        };\n      } else {\n        if (cacheBreakLoop) {\n          console.error(`[${key}] Pullstate detected an infinite loop caused by cacheBreakHook()\nreturning true too often (breaking cache as soon as your action is resolving - hence\ncausing beckoned actions to run the action again) in one of your AsyncActions - Pullstate prevented\nfurther looping. Fix in your cacheBreakHook() is needed.`);\n        } else {\n          cacheBreakWatcher[key] = 0;\n        }\n\n        if (postActionEnabled && cache.results[key][1] && !fromListener) {\n          runPostActionHook(cache.results[key][2], args, stores, context);\n        }\n\n        return {\n          response: cache.results[key],\n          cacheBroke: false,\n          previous: undefined\n        };\n      }\n    }\n\n    return {\n      cacheBroke: false,\n      response: undefined,\n      previous: undefined\n    };\n  }\n\n  function createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, executionContext, customContext) {\n    return () => action(args, stores, customContext).then(resp => {\n      if (currentActionOrd === cache.actionOrd[key]) {\n        if (postActionEnabled) {\n          runPostActionHook(resp, args, stores, executionContext);\n        }\n\n        cache.results[key] = [true, true, resp, false, Date.now()];\n      }\n\n      return resp;\n    }).catch(e => {\n      console.error(e);\n      const result = {\n        payload: null,\n        errorPayload: null,\n        error: true,\n        tags: [EAsyncEndTags.THREW_ERROR],\n        message: e.message\n      };\n\n      if (currentActionOrd === cache.actionOrd[key]) {\n        if (postActionEnabled) {\n          runPostActionHook(result, args, stores, executionContext);\n        }\n\n        cache.results[key] = [true, true, result, false, Date.now()];\n      }\n\n      return result;\n    }).then(resp => {\n      if (currentActionOrd === cache.actionOrd[key]) {\n        delete cache.actions[key];\n\n        if (!onServer) {\n          notifyListeners(key);\n        }\n      }\n\n      return resp;\n    });\n  }\n\n  function checkKeyAndReturnResponse({\n    key,\n    cache,\n    initiate,\n    ssr,\n    args,\n    stores,\n    fromListener = false,\n    postActionEnabled = true,\n    cacheBreakEnabled = true,\n    holdingResult,\n    customContext,\n    customCacheBreak,\n    holdPrevious\n  }) {\n    const cached = getCachedResult({\n      key,\n      cache,\n      args,\n      stores,\n      context: initiate ? EPostActionContext.BECKON_HIT_CACHE : EPostActionContext.WATCH_HIT_CACHE,\n      postActionEnabled,\n      cacheBreakEnabled,\n      fromListener,\n      customCacheBreak\n    });\n\n    if (cached.response) {\n      return cached.response;\n    }\n\n    if (!cache.actions.hasOwnProperty(key)) {\n      const currentActionOrd = actionOrdUpdate(cache, key);\n\n      if (initiate) {\n        if (shortCircuitHook !== undefined) {\n          const shortCircuitResponse = shortCircuitHook({\n            args,\n            stores\n          });\n\n          if (shortCircuitResponse !== false) {\n            runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);\n            cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\n            return cache.results[key];\n          }\n        }\n\n        if (ssr || !onServer) {\n          cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.BECKON_RUN, customContext);\n        }\n\n        if (!onServer) {\n          cache.actions[key]();\n          cache.results[key] = startedButUnfinishedResult;\n        } else {\n          return startedButUnfinishedResult;\n        }\n      } else {\n        const resp = [false, false, {\n          message: \"\",\n          tags: [EAsyncEndTags.UNFINISHED],\n          error: true,\n          payload: null,\n          errorPayload: null\n        }, false, -1];\n\n        if (!onServer) {\n          cache.results[key] = resp;\n        }\n\n        if (holdPrevious) {\n          if (holdingResult) {\n            const response = [...holdingResult];\n            response[3] = true;\n            return response;\n          }\n\n          if (cached.previous != null) {\n            const response = [...cached.previous];\n            response[3] = true;\n            return response;\n          }\n        }\n\n        return resp;\n      }\n    }\n\n    if (holdPrevious) {\n      if (holdingResult) {\n        const response = [...holdingResult];\n        response[3] = true;\n        return response;\n      }\n\n      if (cached.previous != null) {\n        const response = [...cached.previous];\n        response[3] = true;\n        return response;\n      }\n    }\n\n    return startedButUnfinishedResult;\n  }\n\n  const read = (args = {}, {\n    cacheBreakEnabled = true,\n    postActionEnabled = true,\n    key: customKey\n  } = {}) => {\n    const key = _createKey(args, customKey);\n\n    const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n    let stores;\n    let customContext;\n\n    if (onServer || forceContext) {\n      const pullstateContext = useContext(PullstateContext);\n      stores = pullstateContext.stores;\n      customContext = pullstateContext.customContext;\n    } else if (clientStores.loaded) {\n      stores = clientStores.stores;\n    } else {\n      stores = storeErrorProxy;\n    }\n\n    const cached = getCachedResult({\n      key,\n      cache,\n      args,\n      stores,\n      context: EPostActionContext.READ_HIT_CACHE,\n      postActionEnabled,\n      cacheBreakEnabled,\n      fromListener: false\n    });\n\n    if (cached.response) {\n      if (!cached.response[2].error) {\n        return cached.response[2].payload;\n      } else {\n        throw new PullstateAsyncError(cached.response[2].message, cached.response[2].tags);\n      }\n    }\n\n    if (!cache.actions.hasOwnProperty(key)) {\n      if (shortCircuitHook !== undefined) {\n        const shortCircuitResponse = shortCircuitHook({\n          args,\n          stores\n        });\n\n        if (shortCircuitResponse !== false) {\n          runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);\n          cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\n\n          if (!shortCircuitResponse.error) {\n            return shortCircuitResponse.payload;\n          } else {\n            throw new PullstateAsyncError(shortCircuitResponse.message, shortCircuitResponse.tags);\n          }\n        }\n      }\n\n      const currentActionOrd = actionOrdUpdate(cache, key);\n      cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.READ_RUN, customContext);\n\n      if (onServer) {\n        throw new Error(`Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )`);\n      }\n\n      throw cache.actions[key]();\n    }\n\n    if (onServer) {\n      throw new Error(`Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )`);\n    }\n\n    const watchOrd = watchIdOrd++;\n    throw new Promise(resolve => {\n      cache.listeners[key][watchOrd] = () => {\n        delete cache.listeners[key][watchOrd];\n        resolve();\n      };\n    });\n  };\n\n  const useWatch = (args = {}, {\n    initiate = false,\n    ssr = true,\n    postActionEnabled = false,\n    cacheBreakEnabled = false,\n    holdPrevious = false,\n    dormant = false,\n    key: customKey,\n    cacheBreak: customCacheBreak\n  } = {}) => {\n    const responseRef = useRef();\n    const prevKeyRef = useRef(\".\");\n    const key = dormant ? \".\" : _createKey(args, customKey);\n    let watchId = useRef(-1);\n\n    if (watchId.current === -1) {\n      watchId.current = watchIdOrd++;\n    }\n\n    if (!dormant) {\n      if (!shouldUpdate.hasOwnProperty(key)) {\n        shouldUpdate[key] = {\n          [watchId.current]: true\n        };\n      } else {\n        shouldUpdate[key][watchId.current] = true;\n      }\n    }\n\n    const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n    let stores;\n    let customContext;\n\n    if (onServer || forceContext) {\n      const pullstateContext = useContext(PullstateContext);\n      stores = pullstateContext.stores;\n      customContext = pullstateContext.customContext;\n    } else if (clientStores.loaded) {\n      stores = clientStores.stores;\n    } else {\n      stores = storeErrorProxy;\n    }\n\n    if (!onServer) {\n      const onAsyncStateChanged = () => {\n        if (shouldUpdate[key][watchId.current] && !isEqual(responseRef.current, cache.results[key])) {\n          responseRef.current = checkKeyAndReturnResponse({\n            key,\n            cache,\n            initiate,\n            ssr,\n            args,\n            stores,\n            fromListener: true,\n            postActionEnabled,\n            cacheBreakEnabled,\n            holdingResult: undefined,\n            customContext,\n            holdPrevious\n          });\n          setWatchUpdate(prev => {\n            return prev + 1;\n          });\n        }\n      };\n\n      if (!dormant) {\n        if (!cache.listeners.hasOwnProperty(key)) {\n          cache.listeners[key] = {};\n        }\n\n        cache.listeners[key][watchId.current] = onAsyncStateChanged;\n        shouldUpdate[key][watchId.current] = true;\n      }\n\n      useEffect(() => {\n        if (!dormant) {\n          cache.listeners[key][watchId.current] = onAsyncStateChanged;\n          shouldUpdate[key][watchId.current] = true;\n        }\n\n        return () => {\n          if (!dormant) {\n            delete cache.listeners[key][watchId.current];\n            shouldUpdate[key][watchId.current] = false;\n          }\n        };\n      }, [key]);\n    }\n\n    const [_, setWatchUpdate] = useState(0);\n\n    if (dormant) {\n      responseRef.current = holdPrevious && responseRef.current && responseRef.current[1] ? responseRef.current : [false, false, {\n        message: \"\",\n        tags: [EAsyncEndTags.DORMANT],\n        error: true,\n        payload: null\n      }, false, -1];\n      prevKeyRef.current = \".\";\n    } else if (prevKeyRef.current !== key) {\n      if (prevKeyRef.current !== null && shouldUpdate.hasOwnProperty(prevKeyRef.current)) {\n        delete cache.listeners[prevKeyRef.current][watchId.current];\n        shouldUpdate[prevKeyRef.current][watchId.current] = false;\n      }\n\n      prevKeyRef.current = key;\n      responseRef.current = checkKeyAndReturnResponse({\n        key,\n        cache,\n        initiate,\n        ssr,\n        args,\n        stores,\n        fromListener: false,\n        postActionEnabled,\n        cacheBreakEnabled,\n        holdingResult: holdPrevious && responseRef.current && responseRef.current[1] ? responseRef.current : undefined,\n        customContext,\n        customCacheBreak: typeof customCacheBreak === \"boolean\" ? () => customCacheBreak : customCacheBreak,\n        holdPrevious\n      });\n    }\n\n    return responseRef.current;\n  };\n\n  const useBeckon = (args = {}, {\n    ssr = true,\n    postActionEnabled = true,\n    cacheBreakEnabled = true,\n    holdPrevious = false,\n    dormant = false,\n    key\n  } = {}) => {\n    const result = useWatch(args, {\n      initiate: true,\n      ssr,\n      postActionEnabled,\n      cacheBreakEnabled,\n      holdPrevious,\n      dormant,\n      key\n    });\n    return [result[1], result[2], result[3]];\n  };\n\n  const run = async (args = {}, inputs = {}) => {\n    const {\n      treatAsUpdate = false,\n      ignoreShortCircuit = false,\n      respectCache = false,\n      key: customKey,\n      _asyncCache = clientAsyncCache,\n      _stores = clientStores.loaded ? clientStores.stores : storeErrorProxy,\n      _customContext,\n      cacheBreak: customCacheBreak\n    } = inputs;\n\n    const key = _createKey(args, customKey);\n\n    if (respectCache) {\n      const cached = getCachedResult({\n        key,\n        cache: _asyncCache,\n        args,\n        stores: _stores,\n        context: EPostActionContext.RUN_HIT_CACHE,\n        postActionEnabled: true,\n        cacheBreakEnabled: true,\n        fromListener: false,\n        customCacheBreak: typeof customCacheBreak === \"boolean\" ? () => customCacheBreak : customCacheBreak\n      });\n\n      if (cached.response && cached.response[0]) {\n        if (!cached.response[1]) {\n          const watchOrd = watchIdOrd++;\n\n          if (!_asyncCache.listeners.hasOwnProperty(key)) {\n            _asyncCache.listeners[key] = {};\n          }\n\n          return new Promise(resolve => {\n            _asyncCache.listeners[key][watchOrd] = () => {\n              const [, finished, resp] = _asyncCache.results[key];\n\n              if (finished) {\n                delete _asyncCache.listeners[key][watchOrd];\n                resolve(resp);\n              }\n            };\n          });\n        }\n\n        return cached.response[2];\n      }\n    }\n\n    if (!ignoreShortCircuit && shortCircuitHook !== undefined) {\n      const shortCircuitResponse = shortCircuitHook({\n        args,\n        stores: _stores\n      });\n\n      if (shortCircuitResponse !== false) {\n        _asyncCache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\n        runPostActionHook(shortCircuitResponse, args, _stores, EPostActionContext.SHORT_CIRCUIT);\n        notifyListeners(key);\n        return shortCircuitResponse;\n      }\n    }\n\n    const [, prevFinished, prevResp, prevUpdate, prevCacheTime] = _asyncCache.results[key] || [false, false, {\n      error: true,\n      message: \"\",\n      payload: null,\n      tags: [EAsyncEndTags.UNFINISHED]\n    }, false, -1];\n\n    if (prevFinished && treatAsUpdate) {\n      _asyncCache.results[key] = [true, true, prevResp, true, prevCacheTime];\n    } else {\n      _asyncCache.results[key] = [true, false, {\n        error: true,\n        message: \"\",\n        payload: null,\n        tags: [EAsyncEndTags.UNFINISHED]\n      }, false, -1];\n    }\n\n    let currentActionOrd = actionOrdUpdate(_asyncCache, key);\n    _asyncCache.actions[key] = createInternalAction(key, _asyncCache, args, _stores, currentActionOrd, true, EPostActionContext.DIRECT_RUN, _customContext);\n    notifyListeners(key);\n    return _asyncCache.actions[key]();\n  };\n\n  const clearCache = (args = {}, {\n    key: customKey,\n    notify = true\n  } = {}) => {\n    const key = _createKey(args, customKey);\n\n    clearActionCache(key, true, notify);\n  };\n\n  const clearAllCache = ({\n    notify = true\n  } = {}) => {\n    for (const key of Object.keys(clientAsyncCache.actionOrd)) {\n      if (key.startsWith(`${ordinal}-`)) {\n        clearActionCache(key, true, notify);\n      }\n    }\n  };\n\n  const clearAllUnwatchedCache = ({\n    notify = true\n  } = {}) => {\n    for (const key of Object.keys(shouldUpdate)) {\n      if (!Object.values(shouldUpdate[key]).some(su => su)) {\n        delete shouldUpdate[key];\n        clearActionCache(key, false, notify);\n      }\n    }\n  };\n\n  const setCached = (args, result, options) => {\n    const {\n      notify = true,\n      key: customKey\n    } = options || {};\n\n    const key = _createKey(args, customKey);\n\n    const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n    cache.results[key] = [true, true, result, false, Date.now()];\n\n    if (notify) {\n      notifyListeners(key);\n    }\n  };\n\n  const setCachedPayload = (args, payload, options) => {\n    return setCached(args, successResult(payload), options);\n  };\n\n  const updateCached = (args, updater, options) => {\n    const {\n      notify = true,\n      resetTimeCached = true,\n      runPostActionHook: postAction = false,\n      key: customKey\n    } = options || {};\n\n    const key = _createKey(args, customKey);\n\n    const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n\n    if (cache.results.hasOwnProperty(key) && !cache.results[key][2].error) {\n      const currentCached = cache.results[key][2].payload;\n      const newResult = {\n        payload: produce$1(currentCached, s => updater(s, currentCached)),\n        error: false,\n        message: cache.results[key][2].message,\n        tags: cache.results[key][2].tags\n      };\n\n      if (postAction) {\n        runPostActionHook(newResult, args, clientStores.loaded ? clientStores.stores : storeErrorProxy, EPostActionContext.CACHE_UPDATE);\n      }\n\n      cache.results[key] = [true, true, newResult, cache.results[key][3], resetTimeCached ? Date.now() : cache.results[key][4]];\n\n      if (notify) {\n        notifyListeners(key);\n      }\n    }\n  };\n\n  const getCached = (args = {}, options) => {\n    const {\n      checkCacheBreak = false,\n      key: customKey\n    } = options || {};\n\n    const key = _createKey(args, customKey);\n\n    let cacheBreakable = false;\n    const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\n\n    if (cache.results.hasOwnProperty(key)) {\n      if (checkCacheBreak && cacheBreakHook !== undefined) {\n        const stores = onServer ? useContext(PullstateContext).stores : clientStores.loaded ? clientStores.stores : storeErrorProxy;\n\n        if (cacheBreakHook({\n          args,\n          result: cache.results[key][2],\n          stores,\n          timeCached: cache.results[key][4]\n        })) {\n          cacheBreakable = true;\n        }\n      }\n\n      const [started, finished, result, updating, timeCached] = cache.results[key];\n      return {\n        started,\n        finished,\n        result: result,\n        existed: true,\n        cacheBreakable,\n        updating,\n        timeCached\n      };\n    } else {\n      return {\n        started: false,\n        finished: false,\n        result: {\n          message: \"\",\n          tags: [EAsyncEndTags.UNFINISHED],\n          error: true,\n          payload: null,\n          errorPayload: null\n        },\n        updating: false,\n        existed: false,\n        cacheBreakable,\n        timeCached: -1\n      };\n    }\n  };\n\n  let delayedRunActionTimeout;\n\n  const delayedRun = (args = {}, {\n    clearOldRun = true,\n    delay,\n    immediateIfCached = true,\n    ...otherRunOptions\n  }) => {\n    if (clearOldRun) {\n      clearTimeout(delayedRunActionTimeout);\n    }\n\n    if (immediateIfCached) {\n      const {\n        finished,\n        cacheBreakable\n      } = getCached(args, {\n        checkCacheBreak: true\n      });\n\n      if (finished && !cacheBreakable) {\n        run(args, otherRunOptions);\n        return () => {};\n      }\n    }\n\n    let ref = {\n      cancelled: false\n    };\n    delayedRunActionTimeout = setTimeout(() => {\n      if (!ref.cancelled) {\n        run(args, otherRunOptions);\n      }\n    }, delay);\n    return () => {\n      ref.cancelled = true;\n    };\n  };\n\n  const use = (args = {}, {\n    initiate = true,\n    ssr = true,\n    postActionEnabled,\n    cacheBreakEnabled,\n    holdPrevious = false,\n    dormant = false,\n    key,\n    onSuccess,\n    cacheBreak: customCacheBreakHook\n  } = {}) => {\n    if (postActionEnabled == null) {\n      postActionEnabled = initiate;\n    }\n\n    if (cacheBreakEnabled == null) {\n      cacheBreakEnabled = initiate;\n    }\n\n    const raw = useWatch(args, {\n      initiate,\n      ssr,\n      postActionEnabled,\n      cacheBreakEnabled,\n      holdPrevious,\n      dormant,\n      key,\n      cacheBreak: customCacheBreakHook\n    });\n    const [isStarted, isFinished, result, isUpdating] = raw;\n    const isSuccess = isFinished && !result.error;\n    const isFailure = isFinished && result.error;\n\n    if (onSuccess) {\n      useEffect(() => {\n        if (isSuccess && !dormant) {\n          onSuccess(result.payload, args);\n        }\n      }, [isSuccess]);\n    }\n\n    const renderPayload = func => {\n      if (!result.error) {\n        return func(result.payload);\n      }\n\n      return React.Fragment;\n    };\n\n    return {\n      isStarted,\n      isFinished,\n      isUpdating,\n      isSuccess,\n      isFailure,\n      isLoading: isStarted && (!isFinished || isUpdating),\n      endTags: result.tags,\n      error: result.error,\n      payload: result.payload,\n      errorPayload: result.errorPayload,\n      renderPayload,\n      message: result.message,\n      raw,\n      execute: runOptions => run(args, runOptions),\n      clearCached: () => clearCache(args),\n      setCached: (response, options) => {\n        setCached(args, response, options);\n      },\n      setCachedPayload: (payload, options) => {\n        setCachedPayload(args, payload, options);\n      },\n      updateCached: (updater, options) => {\n        updateCached(args, updater, options);\n      }\n    };\n  };\n\n  const useDefer = (inputs = {}) => {\n    const [argState, setArgState] = useState(() => ({\n      key: inputs.key ? inputs.key : deferWaitingKey,\n      args: {}\n    }));\n    const initialResponse = use({}, { ...inputs,\n      key: argState.key,\n      initiate: false\n    });\n    return { ...initialResponse,\n      clearCached: () => {\n        clearCache({}, {\n          key: argState.key\n        });\n      },\n      unwatchExecuted: () => {\n        setArgState({\n          key: deferWaitingKey,\n          args: {}\n        });\n      },\n      setCached: (response, options = {}) => {\n        options.key = argState.key;\n        setCached({}, response, options);\n      },\n      setCachedPayload: (payload, options = {}) => {\n        options.key = argState.key;\n        setCachedPayload({}, payload, options);\n      },\n      updateCached: (updater, options = {}) => {\n        options.key = argState.key;\n        updateCached({}, updater, options);\n      },\n      execute: (args = {}, runOptions) => {\n        var _a;\n\n        const executionKey = (_a = inputs.key) !== null && _a !== void 0 ? _a : _createKey(args);\n\n        if (executionKey !== argState.key) {\n          setArgState({\n            key: executionKey,\n            args\n          });\n        }\n\n        return run(args, { ...runOptions,\n          key: executionKey,\n          cacheBreak: inputs.cacheBreak\n        }).then(resp => {\n          if (inputs.clearOnSuccess) {\n            clearCache({}, {\n              key: executionKey\n            });\n          }\n\n          return resp;\n        });\n      },\n      args: argState.args,\n      key: argState.key\n    };\n  };\n\n  return {\n    use,\n    useDefer,\n    read,\n    useBeckon,\n    useWatch,\n    run,\n    delayedRun,\n    clearCache,\n    clearAllCache,\n    clearAllUnwatchedCache,\n    getCached,\n    setCached,\n    setCachedPayload,\n    updateCached\n  };\n}\n\nconst PullstateContext = React.createContext(null);\n\nconst PullstateProvider = ({\n  instance,\n  children\n}) => {\n  return React.createElement(PullstateContext.Provider, {\n    value: instance\n  }, children);\n};\n\nlet singleton = null;\nconst clientStores = {\n  internalClientStores: true,\n  loaded: false,\n  stores: {}\n};\n\nclass PullstateSingleton {\n  constructor(allStores, options = {}) {\n    this.options = {};\n\n    if (singleton !== null) {\n      console.error(`Pullstate: createPullstate() - Should not be creating the core Pullstate class more than once! In order to re-use pull state, you need to call instantiate() on your already created object.`);\n    }\n\n    singleton = this;\n    clientStores.stores = allStores;\n    clientStores.loaded = true;\n    this.options = options;\n  }\n\n  instantiate({\n    hydrateSnapshot,\n    ssr = false,\n    customContext\n  } = {}) {\n    if (!ssr) {\n      const instantiated = new PullstateInstance(clientStores.stores, false, customContext);\n\n      if (hydrateSnapshot != null) {\n        instantiated.hydrateFromSnapshot(hydrateSnapshot);\n      }\n\n      instantiated.instantiateReactions();\n      return instantiated;\n    }\n\n    const newStores = {};\n\n    for (const storeName of Object.keys(clientStores.stores)) {\n      if (hydrateSnapshot == null) {\n        newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());\n      } else if (hydrateSnapshot.hasOwnProperty(storeName)) {\n        newStores[storeName] = new Store(hydrateSnapshot.allState[storeName]);\n      } else {\n        newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());\n        console.warn(`Pullstate (instantiate): store [${storeName}] didn't hydrate any state (data was non-existent on hydration object)`);\n      }\n\n      newStores[storeName]._setInternalOptions({\n        ssr,\n        reactionCreators: clientStores.stores[storeName]._getReactionCreators()\n      });\n    }\n\n    return new PullstateInstance(newStores, true, customContext);\n  }\n\n  useStores() {\n    return useStores();\n  }\n\n  useInstance() {\n    return useInstance();\n  }\n\n  createAsyncActionDirect(action, options = {}) {\n    return createAsyncActionDirect(action, options);\n  }\n\n  createAsyncAction(action, options = {}) {\n    var _a;\n\n    if (((_a = this.options.asyncActions) === null || _a === void 0 ? void 0 : _a.defaultCachingSeconds) && !options.cacheBreakHook) {\n      options.cacheBreakHook = inputs => inputs.timeCached < Date.now() - this.options.asyncActions.defaultCachingSeconds * 1000;\n    }\n\n    return createAsyncAction(action, options);\n  }\n\n}\n\nclass PullstateInstance {\n  constructor(allStores, ssr, customContext) {\n    this._ssr = false;\n    this._stores = {};\n    this._asyncCache = {\n      listeners: {},\n      results: {},\n      actions: {},\n      actionOrd: {}\n    };\n    this._stores = allStores;\n    this._ssr = ssr;\n    this._customContext = customContext;\n  }\n\n  getAllUnresolvedAsyncActions() {\n    return Object.keys(this._asyncCache.actions).map(key => this._asyncCache.actions[key]());\n  }\n\n  instantiateReactions() {\n    for (const storeName of Object.keys(this._stores)) {\n      this._stores[storeName]._instantiateReactions();\n    }\n  }\n\n  getPullstateSnapshot() {\n    const allState = {};\n\n    for (const storeName of Object.keys(this._stores)) {\n      allState[storeName] = this._stores[storeName].getRawState();\n    }\n\n    return {\n      allState,\n      asyncResults: this._asyncCache.results,\n      asyncActionOrd: this._asyncCache.actionOrd\n    };\n  }\n\n  async resolveAsyncState() {\n    const promises = this.getAllUnresolvedAsyncActions();\n    await Promise.all(promises);\n  }\n\n  hasAsyncStateToResolve() {\n    return Object.keys(this._asyncCache.actions).length > 0;\n  }\n\n  get stores() {\n    return this._stores;\n  }\n\n  get customContext() {\n    return this._customContext;\n  }\n\n  async runAsyncAction(asyncAction, args = {}, runOptions = {}) {\n    if (this._ssr) {\n      runOptions._asyncCache = this._asyncCache;\n      runOptions._stores = this._stores;\n      runOptions._customContext = this._customContext;\n    }\n\n    return await asyncAction.run(args, runOptions);\n  }\n\n  hydrateFromSnapshot(snapshot) {\n    for (const storeName of Object.keys(this._stores)) {\n      if (snapshot.allState.hasOwnProperty(storeName)) {\n        this._stores[storeName]._updateStateWithoutReaction(snapshot.allState[storeName]);\n      } else {\n        console.warn(`${storeName} didn't hydrate any state (data was non-existent on hydration object)`);\n      }\n    }\n\n    clientAsyncCache.results = snapshot.asyncResults || {};\n    clientAsyncCache.actionOrd = snapshot.asyncActionOrd || {};\n  }\n\n}\n\nfunction createPullstateCore(allStores = {}, options = {}) {\n  return new PullstateSingleton(allStores, options);\n}\n\nfunction useStores() {\n  return useContext(PullstateContext).stores;\n}\n\nfunction useInstance() {\n  return useContext(PullstateContext);\n}\n\nvar EAsyncActionInjectType;\n\n(function (EAsyncActionInjectType) {\n  EAsyncActionInjectType[\"WATCH\"] = \"watch\";\n  EAsyncActionInjectType[\"BECKON\"] = \"beckon\";\n})(EAsyncActionInjectType || (EAsyncActionInjectType = {}));\n\nfunction InjectAsyncAction(props) {\n  if (props.type === EAsyncActionInjectType.BECKON) {\n    const response = props.action.useBeckon(props.args, props.options);\n    return props.children(response);\n  }\n\n  const response = props.action.useWatch(props.args, props.options);\n  return props.children(response);\n}\n\nfunction InjectStoreStateOpt({\n  store,\n  paths,\n  children\n}) {\n  const state = useStoreStateOpt(store, paths);\n  return children(state);\n}\n\nfunction registerInDevtools(stores, {\n  namespace = \"\"\n} = {}) {\n  var _a;\n\n  const devToolsExtension = typeof window !== \"undefined\" ? (_a = window) === null || _a === void 0 ? void 0 : _a.__REDUX_DEVTOOLS_EXTENSION__ : undefined;\n\n  if (devToolsExtension) {\n    for (const key of Object.keys(stores)) {\n      const store = stores[key];\n      const devTools = devToolsExtension.connect({\n        name: `${namespace}${key}`\n      });\n      devTools.init(store.getRawState());\n      let ignoreNext = false;\n      store.subscribe(s => s, watched => {\n        if (ignoreNext) {\n          ignoreNext = false;\n          return;\n        }\n\n        devTools.send(\"Change\", watched);\n      });\n      devTools.subscribe(message => {\n        if (message.type === \"DISPATCH\" && message.state) {\n          ignoreNext = true;\n          const parsed = JSON.parse(message.state);\n          store.replace(parsed);\n        }\n      });\n    }\n  }\n}\n\nconst batchState = {};\n\nfunction setupBatch({\n  uiBatchFunction\n}) {\n  batchState.uiBatchFunction = uiBatchFunction;\n}\n\nfunction batch(runUpdates) {\n  if (globalClientState.batching) {\n    throw new Error(\"Pullstate: Can't enact two batch() update functions at the same time-\\n\" + \"make sure you are not running a batch() inside of a batch() by mistake.\");\n  }\n\n  globalClientState.batching = true;\n\n  try {\n    runUpdates();\n  } finally {\n    if (batchState.uiBatchFunction) {\n      batchState.uiBatchFunction(() => {\n        Object.values(globalClientState.flushStores).forEach(store => store.flushBatch(true));\n      });\n    } else {\n      Object.values(globalClientState.flushStores).forEach(store => store.flushBatch(true));\n    }\n\n    globalClientState.flushStores = {};\n    globalClientState.batching = false;\n  }\n}\n\nexport { EAsyncActionInjectType, EAsyncEndTags, EPostActionContext, InjectAsyncAction, InjectStoreState, InjectStoreStateOpt, PullstateContext, PullstateProvider, Store, batch, createAsyncAction, createAsyncActionDirect, createPullstateCore, errorResult, registerInDevtools, setupBatch, successResult, update, useInstance, useLocalStore, useStoreState, useStoreStateOpt, useStores };","map":{"version":3,"sources":["D:/CPE_CMU/1_64/BACOMLAB/LAB/lab-07-ssmilesquare/node_modules/pullstate/dist/index.es.js"],"names":["isEqual","React","useRef","useState","useEffect","useContext","produce$1","enablePatches","produceWithPatches","produce","applyPatches","useStoreState","store","getSubState","deps","updateRef","state","undefined","initialized","current","getRawState","setUpdateTrigger","effectState","shouldUpdate","update","nextSubState","val","_addUpdateListener","_removeUpdateListener","prevDeps","updateListenerOrd","fastGet","obj","path","reduce","cur","key","getSubStateFromPaths","paths","resp","push","useStoreStateOpt","subState","setSubState","onStoreUpdate","currentSubState","ordKey","onStoreUpdateOpt","_addUpdateListenerOpt","_removeUpdateListenerOpt","useLocalStore","initialState","storeRef","Store","globalClientState","storeOrdinal","batching","flushStores","makeSubscriptionFunction","watch","listener","lastWatchState","currentState","nextWatchState","makeReactionFunctionCreator","reaction","forceRun","_optListenerCount","nextState","patches","inversePatches","s","_updateStateWithoutReaction","length","_patchListeners","forEach","Object","keys","getChangedPathsFromPatches","optPathDivider","constructor","updateListeners","ssr","reactions","clientSubscriptions","reactionCreators","optimizedUpdateListeners","optimizedUpdateListenerPaths","optimizedListenerPropertyMap","Function","createInitialState","internalOrdId","_setInternalOptions","map","rc","_getReactionCreators","_instantiateReactions","_getInitialState","_updateState","updateKeyedPaths","batchState","runReaction","runSubscription","updateOrds","Set","keyedPath","ord","add","values","listenerPathsKeyed","join","filter","f","listenToPatches","patchListener","subscribe","func","console","warn","createReaction","runNow","runNowWithSideEffects","creator","useLocalCopyInitial","useLocalCopySnapshot","flushBatch","ignoreError","error","updater","patchesCallback","runUpdates","replace","newState","applyPatchesToStore","changePatches","prev","patch","curKey","p","currentValue","ns","previousValue","currentUpdater","InjectStoreState","on","children","EAsyncEndTags","EPostActionContext","clientAsyncCache","listeners","results","actions","actionOrd","asyncCreationOrdinal","keyFromObject","json","typeOf","prefix","sort","notifyListeners","hasOwnProperty","watchId","clearActionCache","clearPending","notify","actionOrdUpdate","cache","successResult","payload","tags","message","errorPayload","errorResult","RETURNED_ERROR","PullstateAsyncError","Error","storeErrorProxy","Proxy","get","prop","String","startedButUnfinishedResult","UNFINISHED","createAsyncActionDirect","action","options","createAsyncAction","args","stores","customContext","forceContext","shortCircuitHook","cacheBreakHook","postActionHook","subsetKey","actionId","ordinal","onServer","window","_createKey","customKey","deferWaitingKey","cacheBreakWatcher","watchIdOrd","runPostActionHook","result","context","getCachedResult","cacheBreakEnabled","fromListener","postActionEnabled","customCacheBreak","useCacheBreakHook","cacheBreakLoop","timeCached","previous","cacheBroke","response","createInternalAction","currentActionOrd","executionContext","then","Date","now","catch","e","THREW_ERROR","checkKeyAndReturnResponse","initiate","holdingResult","holdPrevious","cached","BECKON_HIT_CACHE","WATCH_HIT_CACHE","shortCircuitResponse","SHORT_CIRCUIT","BECKON_RUN","read","PullstateContext","_asyncCache","pullstateContext","clientStores","loaded","READ_HIT_CACHE","READ_RUN","watchOrd","Promise","resolve","useWatch","dormant","cacheBreak","responseRef","prevKeyRef","onAsyncStateChanged","setWatchUpdate","_","DORMANT","useBeckon","run","inputs","treatAsUpdate","ignoreShortCircuit","respectCache","_stores","_customContext","RUN_HIT_CACHE","finished","prevFinished","prevResp","prevUpdate","prevCacheTime","DIRECT_RUN","clearCache","clearAllCache","startsWith","clearAllUnwatchedCache","some","su","setCached","setCachedPayload","updateCached","resetTimeCached","postAction","currentCached","newResult","CACHE_UPDATE","getCached","checkCacheBreak","cacheBreakable","started","updating","existed","delayedRunActionTimeout","delayedRun","clearOldRun","delay","immediateIfCached","otherRunOptions","clearTimeout","ref","cancelled","setTimeout","use","onSuccess","customCacheBreakHook","raw","isStarted","isFinished","isUpdating","isSuccess","isFailure","renderPayload","Fragment","isLoading","endTags","execute","runOptions","clearCached","useDefer","argState","setArgState","initialResponse","unwatchExecuted","_a","executionKey","clearOnSuccess","createContext","PullstateProvider","instance","createElement","Provider","value","singleton","internalClientStores","PullstateSingleton","allStores","instantiate","hydrateSnapshot","instantiated","PullstateInstance","hydrateFromSnapshot","instantiateReactions","newStores","storeName","allState","useStores","useInstance","asyncActions","defaultCachingSeconds","_ssr","getAllUnresolvedAsyncActions","getPullstateSnapshot","asyncResults","asyncActionOrd","resolveAsyncState","promises","all","hasAsyncStateToResolve","runAsyncAction","asyncAction","snapshot","createPullstateCore","EAsyncActionInjectType","InjectAsyncAction","props","type","BECKON","InjectStoreStateOpt","registerInDevtools","namespace","devToolsExtension","__REDUX_DEVTOOLS_EXTENSION__","devTools","connect","name","init","ignoreNext","watched","send","parsed","JSON","parse","setupBatch","uiBatchFunction","batch"],"mappings":"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","sourcesContent":["import isEqual from'fast-deep-equal/es6';import React,{useRef,useState,useEffect,useContext}from'react';import produce$1,{enablePatches,produceWithPatches,produce,applyPatches}from'immer';function useStoreState(store, getSubState, deps) {\r\n    const updateRef = useRef({ state: undefined, initialized: false });\r\n    if (!updateRef.current.initialized) {\r\n        updateRef.current.state = getSubState ? getSubState(store.getRawState()) : store.getRawState();\r\n        updateRef.current.initialized = true;\r\n    }\r\n    const [, setUpdateTrigger] = useState(0);\r\n    useEffect(() => {\r\n        const effectState = { shouldUpdate: true };\r\n        function update() {\r\n            if (effectState.shouldUpdate) {\r\n                const nextSubState = getSubState\r\n                    ? getSubState(store.getRawState())\r\n                    : store.getRawState();\r\n                if (!isEqual(updateRef.current.state, nextSubState)) {\r\n                    if (effectState.shouldUpdate) {\r\n                        updateRef.current.state = nextSubState;\r\n                        setUpdateTrigger((val) => val + 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        store._addUpdateListener(update);\r\n        update();\r\n        return () => {\r\n            effectState.shouldUpdate = false;\r\n            store._removeUpdateListener(update);\r\n        };\r\n    }, deps !== null && deps !== void 0 ? deps : []);\r\n    if (deps !== undefined) {\r\n        const prevDeps = useRef(deps);\r\n        if (!isEqual(deps, prevDeps)) {\r\n            updateRef.current.state = getSubState(store.getRawState());\r\n        }\r\n    }\r\n    return updateRef.current.state;\r\n}let updateListenerOrd = 0;\r\nfunction fastGet(obj, path) {\r\n    return path.reduce((cur = obj, key) => {\r\n        return cur[key];\r\n    }, undefined);\r\n}\r\nfunction getSubStateFromPaths(store, paths) {\r\n    const state = store.getRawState();\r\n    const resp = [];\r\n    for (const path of paths) {\r\n        resp.push(fastGet(state, path));\r\n    }\r\n    return resp;\r\n}\r\nfunction useStoreStateOpt(store, paths) {\r\n    const [subState, setSubState] = useState(() => getSubStateFromPaths(store, paths));\r\n    const updateRef = useRef({\r\n        shouldUpdate: true,\r\n        onStoreUpdate: null,\r\n        currentSubState: null,\r\n        ordKey: `_${updateListenerOrd++}`,\r\n    });\r\n    updateRef.current.currentSubState = subState;\r\n    if (updateRef.current.onStoreUpdate === null) {\r\n        updateRef.current.onStoreUpdate = function onStoreUpdateOpt() {\r\n            if (updateRef.current.shouldUpdate) {\r\n                setSubState(getSubStateFromPaths(store, paths));\r\n            }\r\n        };\r\n        store._addUpdateListenerOpt(updateRef.current.onStoreUpdate, updateRef.current.ordKey, paths);\r\n    }\r\n    useEffect(() => () => {\r\n        updateRef.current.shouldUpdate = false;\r\n        store._removeUpdateListenerOpt(updateRef.current.ordKey);\r\n    }, []);\r\n    return subState;\r\n}function useLocalStore(initialState, deps) {\r\n    const storeRef = useRef();\r\n    if (storeRef.current == null) {\r\n        storeRef.current = new Store(initialState);\r\n    }\r\n    if (deps !== undefined) {\r\n        const prevDeps = useRef(deps);\r\n        if (!isEqual(deps, prevDeps)) {\r\n            storeRef.current = new Store(initialState);\r\n        }\r\n    }\r\n    return storeRef.current;\r\n}const globalClientState = {\r\n    storeOrdinal: 0,\r\n    batching: false,\r\n    flushStores: {}\r\n};enablePatches();\r\nfunction makeSubscriptionFunction(store, watch, listener) {\r\n    let lastWatchState = watch(store.getRawState());\r\n    return () => {\r\n        const currentState = store.getRawState();\r\n        const nextWatchState = watch(currentState);\r\n        if (!isEqual(nextWatchState, lastWatchState)) {\r\n            listener(nextWatchState, currentState, lastWatchState);\r\n            lastWatchState = nextWatchState;\r\n        }\r\n    };\r\n}\r\nfunction makeReactionFunctionCreator(watch, reaction) {\r\n    return (store) => {\r\n        let lastWatchState = watch(store.getRawState());\r\n        return (forceRun = false) => {\r\n            const currentState = store.getRawState();\r\n            const nextWatchState = watch(currentState);\r\n            if (forceRun || !isEqual(nextWatchState, lastWatchState)) {\r\n                if (store._optListenerCount > 0) {\r\n                    const [nextState, patches, inversePatches] = produceWithPatches(currentState, (s) => reaction(nextWatchState, s, currentState, lastWatchState));\r\n                    store._updateStateWithoutReaction(nextState);\r\n                    lastWatchState = nextWatchState;\r\n                    if (patches.length > 0) {\r\n                        store._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n                        return Object.keys(getChangedPathsFromPatches(patches));\r\n                    }\r\n                }\r\n                else {\r\n                    if (store._patchListeners.length > 0) {\r\n                        const [nextState, patches, inversePatches] = produceWithPatches(currentState, (s) => reaction(nextWatchState, s, currentState, lastWatchState));\r\n                        if (patches.length > 0) {\r\n                            store._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n                        }\r\n                        store._updateStateWithoutReaction(nextState);\r\n                    }\r\n                    else {\r\n                        store._updateStateWithoutReaction(produce(currentState, (s) => reaction(nextWatchState, s, currentState, lastWatchState)));\r\n                    }\r\n                    lastWatchState = nextWatchState;\r\n                }\r\n            }\r\n            return [];\r\n        };\r\n    };\r\n}\r\nconst optPathDivider = \"~._.~\";\r\nclass Store {\r\n    constructor(initialState) {\r\n        this.updateListeners = [];\r\n        this.ssr = false;\r\n        this.reactions = [];\r\n        this.clientSubscriptions = [];\r\n        this.reactionCreators = [];\r\n        this.optimizedUpdateListeners = {};\r\n        this.optimizedUpdateListenerPaths = {};\r\n        this.optimizedListenerPropertyMap = {};\r\n        this._optListenerCount = 0;\r\n        this._patchListeners = [];\r\n        if (initialState instanceof Function) {\r\n            const state = initialState();\r\n            this.currentState = state;\r\n            this.initialState = state;\r\n            this.createInitialState = initialState;\r\n        }\r\n        else {\r\n            this.currentState = initialState;\r\n            this.initialState = initialState;\r\n            this.createInitialState = () => initialState;\r\n        }\r\n        this.internalOrdId = globalClientState.storeOrdinal++;\r\n    }\r\n    _setInternalOptions({ ssr, reactionCreators = [] }) {\r\n        this.ssr = ssr;\r\n        this.reactionCreators = reactionCreators;\r\n        this.reactions = reactionCreators.map((rc) => rc(this));\r\n    }\r\n    _getReactionCreators() {\r\n        return this.reactionCreators;\r\n    }\r\n    _instantiateReactions() {\r\n        this.reactions = this.reactionCreators.map((rc) => rc(this));\r\n    }\r\n    _getInitialState() {\r\n        return this.createInitialState();\r\n    }\r\n    _updateStateWithoutReaction(nextState) {\r\n        this.currentState = nextState;\r\n    }\r\n    _updateState(nextState, updateKeyedPaths = []) {\r\n        this.currentState = nextState;\r\n        this.batchState = undefined;\r\n        for (const runReaction of this.reactions) {\r\n            updateKeyedPaths.push(...runReaction());\r\n        }\r\n        if (!this.ssr) {\r\n            for (const runSubscription of this.clientSubscriptions) {\r\n                runSubscription();\r\n            }\r\n            if (updateKeyedPaths.length > 0) {\r\n                const updateOrds = new Set();\r\n                for (const keyedPath of updateKeyedPaths) {\r\n                    if (this.optimizedListenerPropertyMap[keyedPath]) {\r\n                        for (const ord of this.optimizedListenerPropertyMap[keyedPath]) {\r\n                            updateOrds.add(ord);\r\n                        }\r\n                    }\r\n                }\r\n                for (const ord of updateOrds.values()) {\r\n                    if (this.optimizedUpdateListeners[ord]) {\r\n                        this.optimizedUpdateListeners[ord]();\r\n                    }\r\n                }\r\n            }\r\n            this.updateListeners.forEach((listener) => listener());\r\n        }\r\n    }\r\n    _addUpdateListener(listener) {\r\n        this.updateListeners.push(listener);\r\n    }\r\n    _addUpdateListenerOpt(listener, ordKey, paths) {\r\n        this.optimizedUpdateListeners[ordKey] = listener;\r\n        const listenerPathsKeyed = paths.map((path) => path.join(optPathDivider));\r\n        this.optimizedUpdateListenerPaths[ordKey] = listenerPathsKeyed;\r\n        for (const keyedPath of listenerPathsKeyed) {\r\n            if (this.optimizedListenerPropertyMap[keyedPath] == null) {\r\n                this.optimizedListenerPropertyMap[keyedPath] = [ordKey];\r\n            }\r\n            else {\r\n                this.optimizedListenerPropertyMap[keyedPath].push(ordKey);\r\n            }\r\n        }\r\n        this._optListenerCount++;\r\n    }\r\n    _removeUpdateListener(listener) {\r\n        this.updateListeners = this.updateListeners.filter((f) => f !== listener);\r\n    }\r\n    _removeUpdateListenerOpt(ordKey) {\r\n        const listenerPathsKeyed = this.optimizedUpdateListenerPaths[ordKey];\r\n        for (const keyedPath of listenerPathsKeyed) {\r\n            this.optimizedListenerPropertyMap[keyedPath] = this.optimizedListenerPropertyMap[keyedPath].filter((ord) => ord !== ordKey);\r\n        }\r\n        delete this.optimizedUpdateListenerPaths[ordKey];\r\n        delete this.optimizedUpdateListeners[ordKey];\r\n        this._optListenerCount--;\r\n    }\r\n    listenToPatches(patchListener) {\r\n        this._patchListeners.push(patchListener);\r\n        return () => {\r\n            this._patchListeners = this._patchListeners.filter((f) => f !== patchListener);\r\n        };\r\n    }\r\n    subscribe(watch, listener) {\r\n        if (!this.ssr) {\r\n            const func = makeSubscriptionFunction(this, watch, listener);\r\n            this.clientSubscriptions.push(func);\r\n            return () => {\r\n                this.clientSubscriptions = this.clientSubscriptions.filter((f) => f !== func);\r\n            };\r\n        }\r\n        return () => {\r\n            console.warn(`Pullstate: Subscriptions made on the server side are not registered - so therefor this call to unsubscribe does nothing.`);\r\n        };\r\n    }\r\n    createReaction(watch, reaction, { runNow = false, runNowWithSideEffects = false } = {}) {\r\n        const creator = makeReactionFunctionCreator(watch, reaction);\r\n        this.reactionCreators.push(creator);\r\n        const func = creator(this);\r\n        this.reactions.push(func);\r\n        if (runNow || runNowWithSideEffects) {\r\n            func(true);\r\n            if (runNowWithSideEffects && !this.ssr) {\r\n                this._updateState(this.currentState);\r\n            }\r\n        }\r\n        return () => {\r\n            this.reactions = this.reactions.filter((f) => f !== func);\r\n        };\r\n    }\r\n    getRawState() {\r\n        if (this.batchState !== undefined) {\r\n            return this.batchState;\r\n        }\r\n        else {\r\n            return this.currentState;\r\n        }\r\n    }\r\n    useState(getSubState, deps) {\r\n        return useStoreState(this, getSubState, deps);\r\n    }\r\n    useLocalCopyInitial(deps) {\r\n        return useLocalStore(this.createInitialState, deps);\r\n    }\r\n    useLocalCopySnapshot(deps) {\r\n        return useLocalStore(this.currentState, deps);\r\n    }\r\n    flushBatch(ignoreError = false) {\r\n        if (this.batchState !== undefined) {\r\n            if (this.batchState !== this.currentState) {\r\n                this._updateState(this.batchState);\r\n            }\r\n        }\r\n        else if (!ignoreError) {\r\n            console.error(`Pullstate: Trying to flush batch state which was never created or updated on`);\r\n        }\r\n        this.batchState = undefined;\r\n    }\r\n    update(updater, patchesCallback) {\r\n        if (globalClientState.batching) {\r\n            if (this.batchState === undefined) {\r\n                this.batchState = this.currentState;\r\n                globalClientState.flushStores[this.internalOrdId] = this;\r\n            }\r\n            const func = typeof updater === \"function\";\r\n            const [nextState, patches, inversePatches] = runUpdates(this.batchState, updater, func);\r\n            if (patches.length > 0 && (this._patchListeners.length > 0 || patchesCallback)) {\r\n                if (patchesCallback) {\r\n                    patchesCallback(patches, inversePatches);\r\n                }\r\n                this._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n            }\r\n            this.batchState = nextState;\r\n        }\r\n        else {\r\n            this.batchState = undefined;\r\n            update(this, updater, patchesCallback);\r\n        }\r\n    }\r\n    replace(newState) {\r\n        this._updateState(newState);\r\n    }\r\n    applyPatches(patches) {\r\n        applyPatchesToStore(this, patches);\r\n    }\r\n}\r\nfunction applyPatchesToStore(store, patches) {\r\n    const currentState = store.getRawState();\r\n    const nextState = applyPatches(currentState, patches);\r\n    if (nextState !== currentState) {\r\n        store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));\r\n    }\r\n}\r\nfunction getChangedPathsFromPatches(changePatches, prev = {}) {\r\n    for (const patch of changePatches) {\r\n        let curKey;\r\n        for (const p of patch.path) {\r\n            if (curKey) {\r\n                curKey = `${curKey}${optPathDivider}${p}`;\r\n            }\r\n            else {\r\n                curKey = p;\r\n            }\r\n            prev[curKey] = 1;\r\n        }\r\n    }\r\n    return prev;\r\n}\r\nfunction runUpdates(currentState, updater, func) {\r\n    return func\r\n        ? produceWithPatches(currentState, (s) => updater(s, currentState))\r\n        : updater.reduce(([nextState, patches, inversePatches], currentValue) => {\r\n            const resp = produceWithPatches(nextState, (s) => currentValue(s, nextState));\r\n            patches.push(...resp[1]);\r\n            inversePatches.push(...resp[2]);\r\n            return [resp[0], patches, inversePatches];\r\n        }, [currentState, [], []]);\r\n}\r\nfunction update(store, updater, patchesCallback) {\r\n    const currentState = store.getRawState();\r\n    const func = typeof updater === \"function\";\r\n    if (store._optListenerCount > 0) {\r\n        const [nextState, patches, inversePatches] = runUpdates(currentState, updater, func);\r\n        if (patches.length > 0) {\r\n            if (patchesCallback) {\r\n                patchesCallback(patches, inversePatches);\r\n            }\r\n            store._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n            store._updateState(nextState, Object.keys(getChangedPathsFromPatches(patches)));\r\n        }\r\n    }\r\n    else {\r\n        let nextState;\r\n        if (store._patchListeners.length > 0 || patchesCallback) {\r\n            const [ns, patches, inversePatches] = runUpdates(currentState, updater, func);\r\n            if (patches.length > 0) {\r\n                if (patchesCallback) {\r\n                    patchesCallback(patches, inversePatches);\r\n                }\r\n                store._patchListeners.forEach((listener) => listener(patches, inversePatches));\r\n            }\r\n            nextState = ns;\r\n        }\r\n        else {\r\n            nextState = produce(currentState, (s) => func\r\n                ? updater(s, currentState)\r\n                : updater.reduce((previousValue, currentUpdater) => {\r\n                    return produce(previousValue, (s) => currentUpdater(s, previousValue));\r\n                }, currentState));\r\n        }\r\n        if (nextState !== currentState) {\r\n            store._updateState(nextState);\r\n        }\r\n    }\r\n}function InjectStoreState({ store, on = s => s, children, }) {\r\n    const state = useStoreState(store, on);\r\n    return children(state);\r\n}var EAsyncEndTags;\r\n(function (EAsyncEndTags) {\r\n    EAsyncEndTags[\"THREW_ERROR\"] = \"THREW_ERROR\";\r\n    EAsyncEndTags[\"RETURNED_ERROR\"] = \"RETURNED_ERROR\";\r\n    EAsyncEndTags[\"UNFINISHED\"] = \"UNFINISHED\";\r\n    EAsyncEndTags[\"DORMANT\"] = \"DORMANT\";\r\n})(EAsyncEndTags || (EAsyncEndTags = {}));\r\nvar EPostActionContext;\r\n(function (EPostActionContext) {\r\n    EPostActionContext[\"WATCH_HIT_CACHE\"] = \"WATCH_HIT_CACHE\";\r\n    EPostActionContext[\"BECKON_HIT_CACHE\"] = \"BECKON_HIT_CACHE\";\r\n    EPostActionContext[\"RUN_HIT_CACHE\"] = \"RUN_HIT_CACHE\";\r\n    EPostActionContext[\"READ_HIT_CACHE\"] = \"READ_HIT_CACHE\";\r\n    EPostActionContext[\"READ_RUN\"] = \"READ_RUN\";\r\n    EPostActionContext[\"SHORT_CIRCUIT\"] = \"SHORT_CIRCUIT\";\r\n    EPostActionContext[\"DIRECT_RUN\"] = \"DIRECT_RUN\";\r\n    EPostActionContext[\"BECKON_RUN\"] = \"BECKON_RUN\";\r\n    EPostActionContext[\"CACHE_UPDATE\"] = \"CACHE_UPDATE\";\r\n})(EPostActionContext || (EPostActionContext = {}));const clientAsyncCache = {\r\n    listeners: {},\r\n    results: {},\r\n    actions: {},\r\n    actionOrd: {}\r\n};\r\nlet asyncCreationOrdinal = 0;\r\nfunction keyFromObject(json) {\r\n    if (json === null) {\r\n        return \"(n)\";\r\n    }\r\n    const typeOf = typeof json;\r\n    if (typeOf !== \"object\") {\r\n        if (typeOf === \"undefined\") {\r\n            return \"(u)\";\r\n        }\r\n        else if (typeOf === \"string\") {\r\n            return \":\" + json + \";\";\r\n        }\r\n        else if (typeOf === \"boolean\" || typeOf === \"number\") {\r\n            return \"(\" + json + \")\";\r\n        }\r\n    }\r\n    let prefix = \"{\";\r\n    for (const key of Object.keys(json).sort()) {\r\n        prefix += key + keyFromObject(json[key]);\r\n    }\r\n    return prefix + \"}\";\r\n}\r\nfunction notifyListeners(key) {\r\n    if (clientAsyncCache.listeners.hasOwnProperty(key)) {\r\n        for (const watchId of Object.keys(clientAsyncCache.listeners[key])) {\r\n            clientAsyncCache.listeners[key][watchId]();\r\n        }\r\n    }\r\n}\r\nfunction clearActionCache(key, clearPending = true, notify = true) {\r\n    if (clearPending && clientAsyncCache.actionOrd.hasOwnProperty(key)) {\r\n        clientAsyncCache.actionOrd[key] += 1;\r\n    }\r\n    delete clientAsyncCache.results[key];\r\n    if (notify) {\r\n        notifyListeners(key);\r\n    }\r\n}\r\nfunction actionOrdUpdate(cache, key) {\r\n    if (!cache.actionOrd.hasOwnProperty(key)) {\r\n        cache.actionOrd[key] = 0;\r\n    }\r\n    else {\r\n        cache.actionOrd[key] += 1;\r\n    }\r\n    return cache.actionOrd[key];\r\n}\r\nfunction successResult(payload = null, tags = [], message = \"\") {\r\n    return {\r\n        payload,\r\n        tags,\r\n        message,\r\n        error: false,\r\n        errorPayload: null\r\n    };\r\n}\r\nfunction errorResult(tags = [], message = \"\", errorPayload) {\r\n    return {\r\n        payload: null,\r\n        tags: [EAsyncEndTags.RETURNED_ERROR, ...tags],\r\n        message,\r\n        error: true,\r\n        errorPayload: errorPayload\r\n    };\r\n}\r\nclass PullstateAsyncError extends Error {\r\n    constructor(message, tags) {\r\n        super(message);\r\n        this.tags = tags;\r\n    }\r\n}\r\nlet storeErrorProxy;\r\ntry {\r\n    storeErrorProxy = new Proxy({}, {\r\n        get: function (obj, prop) {\r\n            throw new Error(`Pullstate: Trying to access store (${String(prop)}) inside async actions without the correct usage or setup.\r\nIf this error occurred on the server:\r\n* If using run(), make use of your created instance for this request: instance.runAsyncAction()\r\n* If using read(), useWatch(), useBeckon() etc. - make sure you have properly set up your <PullstateProvider/>\r\n\r\nIf this error occurred on the client:\r\n* Make sure you have created your \"pullstateCore\" object with all your stores, using createPullstateCore(), and are making use of instantiate() before rendering.`);\r\n        }\r\n    });\r\n}\r\ncatch {\r\n    storeErrorProxy = {};\r\n}\r\nconst startedButUnfinishedResult = [\r\n    true,\r\n    false,\r\n    {\r\n        message: \"\",\r\n        tags: [EAsyncEndTags.UNFINISHED],\r\n        error: true,\r\n        payload: null,\r\n        errorPayload: null\r\n    },\r\n    false,\r\n    -1\r\n];\r\nfunction createAsyncActionDirect(action, options = {}) {\r\n    return createAsyncAction(async (args, stores, customContext) => {\r\n        return successResult(await action(args, stores, customContext));\r\n    }, options);\r\n}\r\nfunction createAsyncAction(action, { forceContext = false, shortCircuitHook, cacheBreakHook, postActionHook, subsetKey, actionId } = {}) {\r\n    const ordinal = actionId != null ? `_${actionId}` : asyncCreationOrdinal++;\r\n    const onServer = typeof window === \"undefined\";\r\n    function _createKey(args, customKey) {\r\n        if (customKey != null) {\r\n            return `${ordinal}-c-${customKey}`;\r\n        }\r\n        if (subsetKey !== undefined) {\r\n            return `${ordinal}-${keyFromObject(subsetKey(args))}`;\r\n        }\r\n        return `${ordinal}-${keyFromObject(args)}`;\r\n    }\r\n    const deferWaitingKey = `def_wait_${_createKey({})}`;\r\n    let cacheBreakWatcher = {};\r\n    let watchIdOrd = 0;\r\n    const shouldUpdate = {};\r\n    function runPostActionHook(result, args, stores, context) {\r\n        if (postActionHook !== undefined) {\r\n            postActionHook({ args, result, stores, context });\r\n        }\r\n    }\r\n    function getCachedResult({ args, cache, cacheBreakEnabled, context, fromListener, key, postActionEnabled, stores, customCacheBreak }) {\r\n        const useCacheBreakHook = customCacheBreak !== null && customCacheBreak !== void 0 ? customCacheBreak : cacheBreakHook;\r\n        if (cache.results.hasOwnProperty(key)) {\r\n            const cacheBreakLoop = cacheBreakWatcher.hasOwnProperty(key) && cacheBreakWatcher[key] > 2;\r\n            if (!onServer &&\r\n                !fromListener &&\r\n                cacheBreakEnabled &&\r\n                useCacheBreakHook != null\r\n                && cache.results[key][1] &&\r\n                useCacheBreakHook({\r\n                    args,\r\n                    result: cache.results[key][2],\r\n                    stores,\r\n                    timeCached: cache.results[key][4]\r\n                }) &&\r\n                !cacheBreakLoop) {\r\n                if (cacheBreakWatcher.hasOwnProperty(key)) {\r\n                    cacheBreakWatcher[key]++;\r\n                }\r\n                else {\r\n                    cacheBreakWatcher[key] = 1;\r\n                }\r\n                const previous = cache.results[key];\r\n                delete cache.results[key];\r\n                return { cacheBroke: true, response: undefined, previous };\r\n            }\r\n            else {\r\n                if (cacheBreakLoop) {\r\n                    console.error(`[${key}] Pullstate detected an infinite loop caused by cacheBreakHook()\r\nreturning true too often (breaking cache as soon as your action is resolving - hence\r\ncausing beckoned actions to run the action again) in one of your AsyncActions - Pullstate prevented\r\nfurther looping. Fix in your cacheBreakHook() is needed.`);\r\n                }\r\n                else {\r\n                    cacheBreakWatcher[key] = 0;\r\n                }\r\n                if (postActionEnabled && cache.results[key][1] && !fromListener) {\r\n                    runPostActionHook(cache.results[key][2], args, stores, context);\r\n                }\r\n                return {\r\n                    response: cache.results[key],\r\n                    cacheBroke: false,\r\n                    previous: undefined\r\n                };\r\n            }\r\n        }\r\n        return { cacheBroke: false, response: undefined, previous: undefined };\r\n    }\r\n    function createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, executionContext, customContext) {\r\n        return () => action(args, stores, customContext)\r\n            .then((resp) => {\r\n            if (currentActionOrd === cache.actionOrd[key]) {\r\n                if (postActionEnabled) {\r\n                    runPostActionHook(resp, args, stores, executionContext);\r\n                }\r\n                cache.results[key] = [true, true, resp, false, Date.now()];\r\n            }\r\n            return resp;\r\n        })\r\n            .catch((e) => {\r\n            console.error(e);\r\n            const result = {\r\n                payload: null,\r\n                errorPayload: null,\r\n                error: true,\r\n                tags: [EAsyncEndTags.THREW_ERROR],\r\n                message: e.message\r\n            };\r\n            if (currentActionOrd === cache.actionOrd[key]) {\r\n                if (postActionEnabled) {\r\n                    runPostActionHook(result, args, stores, executionContext);\r\n                }\r\n                cache.results[key] = [true, true, result, false, Date.now()];\r\n            }\r\n            return result;\r\n        })\r\n            .then((resp) => {\r\n            if (currentActionOrd === cache.actionOrd[key]) {\r\n                delete cache.actions[key];\r\n                if (!onServer) {\r\n                    notifyListeners(key);\r\n                }\r\n            }\r\n            return resp;\r\n        });\r\n    }\r\n    function checkKeyAndReturnResponse({ key, cache, initiate, ssr, args, stores, fromListener = false, postActionEnabled = true, cacheBreakEnabled = true, holdingResult, customContext, customCacheBreak, holdPrevious }) {\r\n        const cached = getCachedResult({\r\n            key,\r\n            cache,\r\n            args,\r\n            stores,\r\n            context: initiate ? EPostActionContext.BECKON_HIT_CACHE : EPostActionContext.WATCH_HIT_CACHE,\r\n            postActionEnabled,\r\n            cacheBreakEnabled,\r\n            fromListener,\r\n            customCacheBreak\r\n        });\r\n        if (cached.response) {\r\n            return cached.response;\r\n        }\r\n        if (!cache.actions.hasOwnProperty(key)) {\r\n            const currentActionOrd = actionOrdUpdate(cache, key);\r\n            if (initiate) {\r\n                if (shortCircuitHook !== undefined) {\r\n                    const shortCircuitResponse = shortCircuitHook({ args, stores });\r\n                    if (shortCircuitResponse !== false) {\r\n                        runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);\r\n                        cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\r\n                        return cache.results[key];\r\n                    }\r\n                }\r\n                if (ssr || !onServer) {\r\n                    cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.BECKON_RUN, customContext);\r\n                }\r\n                if (!onServer) {\r\n                    cache.actions[key]();\r\n                    cache.results[key] = startedButUnfinishedResult;\r\n                }\r\n                else {\r\n                    return startedButUnfinishedResult;\r\n                }\r\n            }\r\n            else {\r\n                const resp = [\r\n                    false,\r\n                    false,\r\n                    {\r\n                        message: \"\",\r\n                        tags: [EAsyncEndTags.UNFINISHED],\r\n                        error: true,\r\n                        payload: null,\r\n                        errorPayload: null\r\n                    },\r\n                    false,\r\n                    -1\r\n                ];\r\n                if (!onServer) {\r\n                    cache.results[key] = resp;\r\n                }\r\n                if (holdPrevious) {\r\n                    if (holdingResult) {\r\n                        const response = [...holdingResult];\r\n                        response[3] = true;\r\n                        return response;\r\n                    }\r\n                    if (cached.previous != null) {\r\n                        const response = [...cached.previous];\r\n                        response[3] = true;\r\n                        return response;\r\n                    }\r\n                }\r\n                return resp;\r\n            }\r\n        }\r\n        if (holdPrevious) {\r\n            if (holdingResult) {\r\n                const response = [...holdingResult];\r\n                response[3] = true;\r\n                return response;\r\n            }\r\n            if (cached.previous != null) {\r\n                const response = [...cached.previous];\r\n                response[3] = true;\r\n                return response;\r\n            }\r\n        }\r\n        return startedButUnfinishedResult;\r\n    }\r\n    const read = (args = {}, { cacheBreakEnabled = true, postActionEnabled = true, key: customKey } = {}) => {\r\n        const key = _createKey(args, customKey);\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        let stores;\r\n        let customContext;\r\n        if (onServer || forceContext) {\r\n            const pullstateContext = useContext(PullstateContext);\r\n            stores = pullstateContext.stores;\r\n            customContext = pullstateContext.customContext;\r\n        }\r\n        else if (clientStores.loaded) {\r\n            stores = clientStores.stores;\r\n        }\r\n        else {\r\n            stores = storeErrorProxy;\r\n        }\r\n        const cached = getCachedResult({\r\n            key,\r\n            cache,\r\n            args,\r\n            stores,\r\n            context: EPostActionContext.READ_HIT_CACHE,\r\n            postActionEnabled,\r\n            cacheBreakEnabled,\r\n            fromListener: false\r\n        });\r\n        if (cached.response) {\r\n            if (!cached.response[2].error) {\r\n                return cached.response[2].payload;\r\n            }\r\n            else {\r\n                throw new PullstateAsyncError(cached.response[2].message, cached.response[2].tags);\r\n            }\r\n        }\r\n        if (!cache.actions.hasOwnProperty(key)) {\r\n            if (shortCircuitHook !== undefined) {\r\n                const shortCircuitResponse = shortCircuitHook({ args, stores });\r\n                if (shortCircuitResponse !== false) {\r\n                    runPostActionHook(shortCircuitResponse, args, stores, EPostActionContext.SHORT_CIRCUIT);\r\n                    cache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\r\n                    if (!shortCircuitResponse.error) {\r\n                        return shortCircuitResponse.payload;\r\n                    }\r\n                    else {\r\n                        throw new PullstateAsyncError(shortCircuitResponse.message, shortCircuitResponse.tags);\r\n                    }\r\n                }\r\n            }\r\n            const currentActionOrd = actionOrdUpdate(cache, key);\r\n            cache.actions[key] = createInternalAction(key, cache, args, stores, currentActionOrd, postActionEnabled, EPostActionContext.READ_RUN, customContext);\r\n            if (onServer) {\r\n                throw new Error(`Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )`);\r\n            }\r\n            throw cache.actions[key]();\r\n        }\r\n        if (onServer) {\r\n            throw new Error(`Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )`);\r\n        }\r\n        const watchOrd = watchIdOrd++;\r\n        throw new Promise((resolve) => {\r\n            cache.listeners[key][watchOrd] = () => {\r\n                delete cache.listeners[key][watchOrd];\r\n                resolve();\r\n            };\r\n        });\r\n    };\r\n    const useWatch = (args = {}, { initiate = false, ssr = true, postActionEnabled = false, cacheBreakEnabled = false, holdPrevious = false, dormant = false, key: customKey, cacheBreak: customCacheBreak } = {}) => {\r\n        const responseRef = useRef();\r\n        const prevKeyRef = useRef(\".\");\r\n        const key = dormant ? \".\" : _createKey(args, customKey);\r\n        let watchId = useRef(-1);\r\n        if (watchId.current === -1) {\r\n            watchId.current = watchIdOrd++;\r\n        }\r\n        if (!dormant) {\r\n            if (!shouldUpdate.hasOwnProperty(key)) {\r\n                shouldUpdate[key] = {\r\n                    [watchId.current]: true\r\n                };\r\n            }\r\n            else {\r\n                shouldUpdate[key][watchId.current] = true;\r\n            }\r\n        }\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        let stores;\r\n        let customContext;\r\n        if (onServer || forceContext) {\r\n            const pullstateContext = useContext(PullstateContext);\r\n            stores = pullstateContext.stores;\r\n            customContext = pullstateContext.customContext;\r\n        }\r\n        else if (clientStores.loaded) {\r\n            stores = clientStores.stores;\r\n        }\r\n        else {\r\n            stores = storeErrorProxy;\r\n        }\r\n        if (!onServer) {\r\n            const onAsyncStateChanged = () => {\r\n                if (shouldUpdate[key][watchId.current] && !isEqual(responseRef.current, cache.results[key])) {\r\n                    responseRef.current = checkKeyAndReturnResponse({\r\n                        key,\r\n                        cache,\r\n                        initiate,\r\n                        ssr,\r\n                        args,\r\n                        stores,\r\n                        fromListener: true,\r\n                        postActionEnabled,\r\n                        cacheBreakEnabled,\r\n                        holdingResult: undefined,\r\n                        customContext,\r\n                        holdPrevious\r\n                    });\r\n                    setWatchUpdate((prev) => {\r\n                        return prev + 1;\r\n                    });\r\n                }\r\n            };\r\n            if (!dormant) {\r\n                if (!cache.listeners.hasOwnProperty(key)) {\r\n                    cache.listeners[key] = {};\r\n                }\r\n                cache.listeners[key][watchId.current] = onAsyncStateChanged;\r\n                shouldUpdate[key][watchId.current] = true;\r\n            }\r\n            useEffect(() => {\r\n                if (!dormant) {\r\n                    cache.listeners[key][watchId.current] = onAsyncStateChanged;\r\n                    shouldUpdate[key][watchId.current] = true;\r\n                }\r\n                return () => {\r\n                    if (!dormant) {\r\n                        delete cache.listeners[key][watchId.current];\r\n                        shouldUpdate[key][watchId.current] = false;\r\n                    }\r\n                };\r\n            }, [key]);\r\n        }\r\n        const [_, setWatchUpdate] = useState(0);\r\n        if (dormant) {\r\n            responseRef.current =\r\n                holdPrevious && responseRef.current && responseRef.current[1]\r\n                    ? responseRef.current\r\n                    : [\r\n                        false,\r\n                        false,\r\n                        {\r\n                            message: \"\",\r\n                            tags: [EAsyncEndTags.DORMANT],\r\n                            error: true,\r\n                            payload: null\r\n                        },\r\n                        false,\r\n                        -1\r\n                    ];\r\n            prevKeyRef.current = \".\";\r\n        }\r\n        else if (prevKeyRef.current !== key) {\r\n            if (prevKeyRef.current !== null && shouldUpdate.hasOwnProperty(prevKeyRef.current)) {\r\n                delete cache.listeners[prevKeyRef.current][watchId.current];\r\n                shouldUpdate[prevKeyRef.current][watchId.current] = false;\r\n            }\r\n            prevKeyRef.current = key;\r\n            responseRef.current = checkKeyAndReturnResponse({\r\n                key,\r\n                cache,\r\n                initiate,\r\n                ssr,\r\n                args,\r\n                stores,\r\n                fromListener: false,\r\n                postActionEnabled,\r\n                cacheBreakEnabled,\r\n                holdingResult: holdPrevious && responseRef.current && responseRef.current[1] ? responseRef.current : undefined,\r\n                customContext,\r\n                customCacheBreak: typeof customCacheBreak === \"boolean\" ? () => customCacheBreak : customCacheBreak,\r\n                holdPrevious\r\n            });\r\n        }\r\n        return responseRef.current;\r\n    };\r\n    const useBeckon = (args = {}, { ssr = true, postActionEnabled = true, cacheBreakEnabled = true, holdPrevious = false, dormant = false, key } = {}) => {\r\n        const result = useWatch(args, {\r\n            initiate: true,\r\n            ssr,\r\n            postActionEnabled,\r\n            cacheBreakEnabled,\r\n            holdPrevious,\r\n            dormant,\r\n            key\r\n        });\r\n        return [result[1], result[2], result[3]];\r\n    };\r\n    const run = async (args = {}, inputs = {}) => {\r\n        const { treatAsUpdate = false, ignoreShortCircuit = false, respectCache = false, key: customKey, _asyncCache = clientAsyncCache, _stores = clientStores.loaded ? clientStores.stores : storeErrorProxy, _customContext, cacheBreak: customCacheBreak } = inputs;\r\n        const key = _createKey(args, customKey);\r\n        if (respectCache) {\r\n            const cached = getCachedResult({\r\n                key,\r\n                cache: _asyncCache,\r\n                args,\r\n                stores: _stores,\r\n                context: EPostActionContext.RUN_HIT_CACHE,\r\n                postActionEnabled: true,\r\n                cacheBreakEnabled: true,\r\n                fromListener: false,\r\n                customCacheBreak: typeof customCacheBreak === \"boolean\" ? () => customCacheBreak : customCacheBreak\r\n            });\r\n            if (cached.response && cached.response[0]) {\r\n                if (!cached.response[1]) {\r\n                    const watchOrd = watchIdOrd++;\r\n                    if (!_asyncCache.listeners.hasOwnProperty(key)) {\r\n                        _asyncCache.listeners[key] = {};\r\n                    }\r\n                    return new Promise((resolve) => {\r\n                        _asyncCache.listeners[key][watchOrd] = () => {\r\n                            const [, finished, resp] = _asyncCache.results[key];\r\n                            if (finished) {\r\n                                delete _asyncCache.listeners[key][watchOrd];\r\n                                resolve(resp);\r\n                            }\r\n                        };\r\n                    });\r\n                }\r\n                return cached.response[2];\r\n            }\r\n        }\r\n        if (!ignoreShortCircuit && shortCircuitHook !== undefined) {\r\n            const shortCircuitResponse = shortCircuitHook({ args, stores: _stores });\r\n            if (shortCircuitResponse !== false) {\r\n                _asyncCache.results[key] = [true, true, shortCircuitResponse, false, Date.now()];\r\n                runPostActionHook(shortCircuitResponse, args, _stores, EPostActionContext.SHORT_CIRCUIT);\r\n                notifyListeners(key);\r\n                return shortCircuitResponse;\r\n            }\r\n        }\r\n        const [, prevFinished, prevResp, prevUpdate, prevCacheTime] = _asyncCache.results[key] || [\r\n            false,\r\n            false,\r\n            {\r\n                error: true,\r\n                message: \"\",\r\n                payload: null,\r\n                tags: [EAsyncEndTags.UNFINISHED]\r\n            },\r\n            false,\r\n            -1\r\n        ];\r\n        if (prevFinished && treatAsUpdate) {\r\n            _asyncCache.results[key] = [true, true, prevResp, true, prevCacheTime];\r\n        }\r\n        else {\r\n            _asyncCache.results[key] = [\r\n                true,\r\n                false,\r\n                {\r\n                    error: true,\r\n                    message: \"\",\r\n                    payload: null,\r\n                    tags: [EAsyncEndTags.UNFINISHED]\r\n                },\r\n                false,\r\n                -1\r\n            ];\r\n        }\r\n        let currentActionOrd = actionOrdUpdate(_asyncCache, key);\r\n        _asyncCache.actions[key] = createInternalAction(key, _asyncCache, args, _stores, currentActionOrd, true, EPostActionContext.DIRECT_RUN, _customContext);\r\n        notifyListeners(key);\r\n        return _asyncCache.actions[key]();\r\n    };\r\n    const clearCache = (args = {}, { key: customKey, notify = true } = {}) => {\r\n        const key = _createKey(args, customKey);\r\n        clearActionCache(key, true, notify);\r\n    };\r\n    const clearAllCache = ({ notify = true } = {}) => {\r\n        for (const key of Object.keys(clientAsyncCache.actionOrd)) {\r\n            if (key.startsWith(`${ordinal}-`)) {\r\n                clearActionCache(key, true, notify);\r\n            }\r\n        }\r\n    };\r\n    const clearAllUnwatchedCache = ({ notify = true } = {}) => {\r\n        for (const key of Object.keys(shouldUpdate)) {\r\n            if (!Object.values(shouldUpdate[key]).some((su) => su)) {\r\n                delete shouldUpdate[key];\r\n                clearActionCache(key, false, notify);\r\n            }\r\n        }\r\n    };\r\n    const setCached = (args, result, options) => {\r\n        const { notify = true, key: customKey } = options || {};\r\n        const key = _createKey(args, customKey);\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        cache.results[key] = [true, true, result, false, Date.now()];\r\n        if (notify) {\r\n            notifyListeners(key);\r\n        }\r\n    };\r\n    const setCachedPayload = (args, payload, options) => {\r\n        return setCached(args, successResult(payload), options);\r\n    };\r\n    const updateCached = (args, updater, options) => {\r\n        const { notify = true, resetTimeCached = true, runPostActionHook: postAction = false, key: customKey } = options || {};\r\n        const key = _createKey(args, customKey);\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        if (cache.results.hasOwnProperty(key) && !cache.results[key][2].error) {\r\n            const currentCached = cache.results[key][2].payload;\r\n            const newResult = {\r\n                payload: produce$1(currentCached, (s) => updater(s, currentCached)),\r\n                error: false,\r\n                message: cache.results[key][2].message,\r\n                tags: cache.results[key][2].tags\r\n            };\r\n            if (postAction) {\r\n                runPostActionHook(newResult, args, clientStores.loaded ? clientStores.stores : storeErrorProxy, EPostActionContext.CACHE_UPDATE);\r\n            }\r\n            cache.results[key] = [\r\n                true,\r\n                true,\r\n                newResult,\r\n                cache.results[key][3],\r\n                resetTimeCached ? Date.now() : cache.results[key][4]\r\n            ];\r\n            if (notify) {\r\n                notifyListeners(key);\r\n            }\r\n        }\r\n    };\r\n    const getCached = (args = {}, options) => {\r\n        const { checkCacheBreak = false, key: customKey } = options || {};\r\n        const key = _createKey(args, customKey);\r\n        let cacheBreakable = false;\r\n        const cache = onServer ? useContext(PullstateContext)._asyncCache : clientAsyncCache;\r\n        if (cache.results.hasOwnProperty(key)) {\r\n            if (checkCacheBreak && cacheBreakHook !== undefined) {\r\n                const stores = onServer\r\n                    ? useContext(PullstateContext).stores\r\n                    : clientStores.loaded\r\n                        ? clientStores.stores\r\n                        : storeErrorProxy;\r\n                if (cacheBreakHook({\r\n                    args,\r\n                    result: cache.results[key][2],\r\n                    stores,\r\n                    timeCached: cache.results[key][4]\r\n                })) {\r\n                    cacheBreakable = true;\r\n                }\r\n            }\r\n            const [started, finished, result, updating, timeCached] = cache.results[key];\r\n            return {\r\n                started,\r\n                finished,\r\n                result: result,\r\n                existed: true,\r\n                cacheBreakable,\r\n                updating,\r\n                timeCached\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                started: false,\r\n                finished: false,\r\n                result: {\r\n                    message: \"\",\r\n                    tags: [EAsyncEndTags.UNFINISHED],\r\n                    error: true,\r\n                    payload: null,\r\n                    errorPayload: null\r\n                },\r\n                updating: false,\r\n                existed: false,\r\n                cacheBreakable,\r\n                timeCached: -1\r\n            };\r\n        }\r\n    };\r\n    let delayedRunActionTimeout;\r\n    const delayedRun = (args = {}, { clearOldRun = true, delay, immediateIfCached = true, ...otherRunOptions }) => {\r\n        if (clearOldRun) {\r\n            clearTimeout(delayedRunActionTimeout);\r\n        }\r\n        if (immediateIfCached) {\r\n            const { finished, cacheBreakable } = getCached(args, { checkCacheBreak: true });\r\n            if (finished && !cacheBreakable) {\r\n                run(args, otherRunOptions);\r\n                return () => {\r\n                };\r\n            }\r\n        }\r\n        let ref = { cancelled: false };\r\n        delayedRunActionTimeout = setTimeout(() => {\r\n            if (!ref.cancelled) {\r\n                run(args, otherRunOptions);\r\n            }\r\n        }, delay);\r\n        return () => {\r\n            ref.cancelled = true;\r\n        };\r\n    };\r\n    const use = (args = {}, { initiate = true, ssr = true, postActionEnabled, cacheBreakEnabled, holdPrevious = false, dormant = false, key, onSuccess, cacheBreak: customCacheBreakHook } = {}) => {\r\n        if (postActionEnabled == null) {\r\n            postActionEnabled = initiate;\r\n        }\r\n        if (cacheBreakEnabled == null) {\r\n            cacheBreakEnabled = initiate;\r\n        }\r\n        const raw = useWatch(args, {\r\n            initiate,\r\n            ssr,\r\n            postActionEnabled,\r\n            cacheBreakEnabled,\r\n            holdPrevious,\r\n            dormant,\r\n            key,\r\n            cacheBreak: customCacheBreakHook\r\n        });\r\n        const [isStarted, isFinished, result, isUpdating] = raw;\r\n        const isSuccess = isFinished && !result.error;\r\n        const isFailure = isFinished && result.error;\r\n        if (onSuccess) {\r\n            useEffect(() => {\r\n                if (isSuccess && !dormant) {\r\n                    onSuccess(result.payload, args);\r\n                }\r\n            }, [isSuccess]);\r\n        }\r\n        const renderPayload = (func) => {\r\n            if (!result.error) {\r\n                return func(result.payload);\r\n            }\r\n            return React.Fragment;\r\n        };\r\n        return {\r\n            isStarted,\r\n            isFinished,\r\n            isUpdating,\r\n            isSuccess,\r\n            isFailure,\r\n            isLoading: isStarted && (!isFinished || isUpdating),\r\n            endTags: result.tags,\r\n            error: result.error,\r\n            payload: result.payload,\r\n            errorPayload: result.errorPayload,\r\n            renderPayload,\r\n            message: result.message,\r\n            raw,\r\n            execute: (runOptions) => run(args, runOptions),\r\n            clearCached: () => clearCache(args),\r\n            setCached: (response, options) => {\r\n                setCached(args, response, options);\r\n            },\r\n            setCachedPayload: (payload, options) => {\r\n                setCachedPayload(args, payload, options);\r\n            },\r\n            updateCached: (updater, options) => {\r\n                updateCached(args, updater, options);\r\n            }\r\n        };\r\n    };\r\n    const useDefer = (inputs = {}) => {\r\n        const [argState, setArgState] = useState(() => ({\r\n            key: inputs.key ? inputs.key : deferWaitingKey,\r\n            args: {}\r\n        }));\r\n        const initialResponse = use({}, {\r\n            ...inputs,\r\n            key: argState.key,\r\n            initiate: false\r\n        });\r\n        return {\r\n            ...initialResponse,\r\n            clearCached: () => {\r\n                clearCache({}, { key: argState.key });\r\n            },\r\n            unwatchExecuted: () => {\r\n                setArgState({ key: deferWaitingKey, args: {} });\r\n            },\r\n            setCached: (response, options = {}) => {\r\n                options.key = argState.key;\r\n                setCached({}, response, options);\r\n            },\r\n            setCachedPayload: (payload, options = {}) => {\r\n                options.key = argState.key;\r\n                setCachedPayload({}, payload, options);\r\n            },\r\n            updateCached: (updater, options = {}) => {\r\n                options.key = argState.key;\r\n                updateCached({}, updater, options);\r\n            },\r\n            execute: (args = {}, runOptions) => {\r\n                var _a;\r\n                const executionKey = (_a = inputs.key) !== null && _a !== void 0 ? _a : _createKey(args);\r\n                if (executionKey !== argState.key) {\r\n                    setArgState({ key: executionKey, args });\r\n                }\r\n                return run(args, {\r\n                    ...runOptions,\r\n                    key: executionKey,\r\n                    cacheBreak: inputs.cacheBreak\r\n                }).then(resp => {\r\n                    if (inputs.clearOnSuccess) {\r\n                        clearCache({}, { key: executionKey });\r\n                    }\r\n                    return resp;\r\n                });\r\n            },\r\n            args: argState.args,\r\n            key: argState.key\r\n        };\r\n    };\r\n    return {\r\n        use,\r\n        useDefer,\r\n        read,\r\n        useBeckon,\r\n        useWatch,\r\n        run,\r\n        delayedRun,\r\n        clearCache,\r\n        clearAllCache,\r\n        clearAllUnwatchedCache,\r\n        getCached,\r\n        setCached,\r\n        setCachedPayload,\r\n        updateCached\r\n    };\r\n}const PullstateContext = React.createContext(null);\r\nconst PullstateProvider = ({ instance, children }) => {\r\n    return React.createElement(PullstateContext.Provider, { value: instance }, children);\r\n};\r\nlet singleton = null;\r\nconst clientStores = {\r\n    internalClientStores: true,\r\n    loaded: false,\r\n    stores: {}\r\n};\r\nclass PullstateSingleton {\r\n    constructor(allStores, options = {}) {\r\n        this.options = {};\r\n        if (singleton !== null) {\r\n            console.error(`Pullstate: createPullstate() - Should not be creating the core Pullstate class more than once! In order to re-use pull state, you need to call instantiate() on your already created object.`);\r\n        }\r\n        singleton = this;\r\n        clientStores.stores = allStores;\r\n        clientStores.loaded = true;\r\n        this.options = options;\r\n    }\r\n    instantiate({ hydrateSnapshot, ssr = false, customContext } = {}) {\r\n        if (!ssr) {\r\n            const instantiated = new PullstateInstance(clientStores.stores, false, customContext);\r\n            if (hydrateSnapshot != null) {\r\n                instantiated.hydrateFromSnapshot(hydrateSnapshot);\r\n            }\r\n            instantiated.instantiateReactions();\r\n            return instantiated;\r\n        }\r\n        const newStores = {};\r\n        for (const storeName of Object.keys(clientStores.stores)) {\r\n            if (hydrateSnapshot == null) {\r\n                newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());\r\n            }\r\n            else if (hydrateSnapshot.hasOwnProperty(storeName)) {\r\n                newStores[storeName] = new Store(hydrateSnapshot.allState[storeName]);\r\n            }\r\n            else {\r\n                newStores[storeName] = new Store(clientStores.stores[storeName]._getInitialState());\r\n                console.warn(`Pullstate (instantiate): store [${storeName}] didn't hydrate any state (data was non-existent on hydration object)`);\r\n            }\r\n            newStores[storeName]._setInternalOptions({\r\n                ssr,\r\n                reactionCreators: clientStores.stores[storeName]._getReactionCreators()\r\n            });\r\n        }\r\n        return new PullstateInstance(newStores, true, customContext);\r\n    }\r\n    useStores() {\r\n        return useStores();\r\n    }\r\n    useInstance() {\r\n        return useInstance();\r\n    }\r\n    createAsyncActionDirect(action, options = {}) {\r\n        return createAsyncActionDirect(action, options);\r\n    }\r\n    createAsyncAction(action, options = {}) {\r\n        var _a;\r\n        if (((_a = this.options.asyncActions) === null || _a === void 0 ? void 0 : _a.defaultCachingSeconds) && !options.cacheBreakHook) {\r\n            options.cacheBreakHook = (inputs) => inputs.timeCached < Date.now() - this.options.asyncActions.defaultCachingSeconds * 1000;\r\n        }\r\n        return createAsyncAction(action, options);\r\n    }\r\n}\r\nclass PullstateInstance {\r\n    constructor(allStores, ssr, customContext) {\r\n        this._ssr = false;\r\n        this._stores = {};\r\n        this._asyncCache = {\r\n            listeners: {},\r\n            results: {},\r\n            actions: {},\r\n            actionOrd: {}\r\n        };\r\n        this._stores = allStores;\r\n        this._ssr = ssr;\r\n        this._customContext = customContext;\r\n    }\r\n    getAllUnresolvedAsyncActions() {\r\n        return Object.keys(this._asyncCache.actions).map((key) => this._asyncCache.actions[key]());\r\n    }\r\n    instantiateReactions() {\r\n        for (const storeName of Object.keys(this._stores)) {\r\n            this._stores[storeName]._instantiateReactions();\r\n        }\r\n    }\r\n    getPullstateSnapshot() {\r\n        const allState = {};\r\n        for (const storeName of Object.keys(this._stores)) {\r\n            allState[storeName] = this._stores[storeName].getRawState();\r\n        }\r\n        return { allState, asyncResults: this._asyncCache.results, asyncActionOrd: this._asyncCache.actionOrd };\r\n    }\r\n    async resolveAsyncState() {\r\n        const promises = this.getAllUnresolvedAsyncActions();\r\n        await Promise.all(promises);\r\n    }\r\n    hasAsyncStateToResolve() {\r\n        return Object.keys(this._asyncCache.actions).length > 0;\r\n    }\r\n    get stores() {\r\n        return this._stores;\r\n    }\r\n    get customContext() {\r\n        return this._customContext;\r\n    }\r\n    async runAsyncAction(asyncAction, args = {}, runOptions = {}) {\r\n        if (this._ssr) {\r\n            runOptions._asyncCache = this._asyncCache;\r\n            runOptions._stores = this._stores;\r\n            runOptions._customContext = this._customContext;\r\n        }\r\n        return await asyncAction.run(args, runOptions);\r\n    }\r\n    hydrateFromSnapshot(snapshot) {\r\n        for (const storeName of Object.keys(this._stores)) {\r\n            if (snapshot.allState.hasOwnProperty(storeName)) {\r\n                this._stores[storeName]._updateStateWithoutReaction(snapshot.allState[storeName]);\r\n            }\r\n            else {\r\n                console.warn(`${storeName} didn't hydrate any state (data was non-existent on hydration object)`);\r\n            }\r\n        }\r\n        clientAsyncCache.results = snapshot.asyncResults || {};\r\n        clientAsyncCache.actionOrd = snapshot.asyncActionOrd || {};\r\n    }\r\n}\r\nfunction createPullstateCore(allStores = {}, options = {}) {\r\n    return new PullstateSingleton(allStores, options);\r\n}\r\nfunction useStores() {\r\n    return useContext(PullstateContext).stores;\r\n}\r\nfunction useInstance() {\r\n    return useContext(PullstateContext);\r\n}var EAsyncActionInjectType;\r\n(function (EAsyncActionInjectType) {\r\n    EAsyncActionInjectType[\"WATCH\"] = \"watch\";\r\n    EAsyncActionInjectType[\"BECKON\"] = \"beckon\";\r\n})(EAsyncActionInjectType || (EAsyncActionInjectType = {}));\r\nfunction InjectAsyncAction(props) {\r\n    if (props.type === EAsyncActionInjectType.BECKON) {\r\n        const response = props.action.useBeckon(props.args, props.options);\r\n        return props.children(response);\r\n    }\r\n    const response = props.action.useWatch(props.args, props.options);\r\n    return props.children(response);\r\n}function InjectStoreStateOpt({ store, paths, children }) {\r\n    const state = useStoreStateOpt(store, paths);\r\n    return children(state);\r\n}function registerInDevtools(stores, { namespace = \"\" } = {}) {\r\n    var _a;\r\n    const devToolsExtension = typeof window !== \"undefined\" ? (_a = window) === null || _a === void 0 ? void 0 : _a.__REDUX_DEVTOOLS_EXTENSION__ : undefined;\r\n    if (devToolsExtension) {\r\n        for (const key of Object.keys(stores)) {\r\n            const store = stores[key];\r\n            const devTools = devToolsExtension.connect({ name: `${namespace}${key}` });\r\n            devTools.init(store.getRawState());\r\n            let ignoreNext = false;\r\n            store.subscribe((s) => s, (watched) => {\r\n                if (ignoreNext) {\r\n                    ignoreNext = false;\r\n                    return;\r\n                }\r\n                devTools.send(\"Change\", watched);\r\n            });\r\n            devTools.subscribe((message) => {\r\n                if (message.type === \"DISPATCH\" && message.state) {\r\n                    ignoreNext = true;\r\n                    const parsed = JSON.parse(message.state);\r\n                    store.replace(parsed);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}const batchState = {};\r\nfunction setupBatch({ uiBatchFunction }) {\r\n    batchState.uiBatchFunction = uiBatchFunction;\r\n}\r\nfunction batch(runUpdates) {\r\n    if (globalClientState.batching) {\r\n        throw new Error(\"Pullstate: Can't enact two batch() update functions at the same time-\\n\" +\r\n            \"make sure you are not running a batch() inside of a batch() by mistake.\");\r\n    }\r\n    globalClientState.batching = true;\r\n    try {\r\n        runUpdates();\r\n    }\r\n    finally {\r\n        if (batchState.uiBatchFunction) {\r\n            batchState.uiBatchFunction(() => {\r\n                Object.values(globalClientState.flushStores).forEach(store => store.flushBatch(true));\r\n            });\r\n        }\r\n        else {\r\n            Object.values(globalClientState.flushStores).forEach(store => store.flushBatch(true));\r\n        }\r\n        globalClientState.flushStores = {};\r\n        globalClientState.batching = false;\r\n    }\r\n}export{EAsyncActionInjectType,EAsyncEndTags,EPostActionContext,InjectAsyncAction,InjectStoreState,InjectStoreStateOpt,PullstateContext,PullstateProvider,Store,batch,createAsyncAction,createAsyncActionDirect,createPullstateCore,errorResult,registerInDevtools,setupBatch,successResult,update,useInstance,useLocalStore,useStoreState,useStoreStateOpt,useStores};"]},"metadata":{},"sourceType":"module"}