!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("react"),require("immer")):"function"==typeof define&&define.amd?define(["exports","react","immer"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).pullstate={},t.React,t.immer)}(this,(function(t,e,s){"use strict";function r(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var n=r(e),o=r(s),a=function t(e,s){if(e===s)return!0;if(e&&s&&"object"==typeof e&&"object"==typeof s){if(e.constructor!==s.constructor)return!1;var r,n,o;if(Array.isArray(e)){if((r=e.length)!=s.length)return!1;for(n=r;0!=n--;)if(!t(e[n],s[n]))return!1;return!0}if(e instanceof Map&&s instanceof Map){if(e.size!==s.size)return!1;for(n of e.entries())if(!s.has(n[0]))return!1;for(n of e.entries())if(!t(n[1],s.get(n[0])))return!1;return!0}if(e instanceof Set&&s instanceof Set){if(e.size!==s.size)return!1;for(n of e.entries())if(!s.has(n[0]))return!1;return!0}if(ArrayBuffer.isView(e)&&ArrayBuffer.isView(s)){if((r=e.length)!=s.length)return!1;for(n=r;0!=n--;)if(e[n]!==s[n])return!1;return!0}if(e.constructor===RegExp)return e.source===s.source&&e.flags===s.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===s.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===s.toString();if((r=(o=Object.keys(e)).length)!==Object.keys(s).length)return!1;for(n=r;0!=n--;)if(!Object.prototype.hasOwnProperty.call(s,o[n]))return!1;for(n=r;0!=n--;){var a=o[n];if(!t(e[a],s[a]))return!1}return!0}return e!=e&&s!=s};function i(t,s,r){const n=e.useRef({state:void 0,initialized:!1});n.current.initialized||(n.current.state=s?s(t.getRawState()):t.getRawState(),n.current.initialized=!0);const[,o]=e.useState(0);if(e.useEffect((()=>{const e={shouldUpdate:!0};function r(){if(e.shouldUpdate){const r=s?s(t.getRawState()):t.getRawState();a(n.current.state,r)||e.shouldUpdate&&(n.current.state=r,o((t=>t+1)))}}return t._addUpdateListener(r),r(),()=>{e.shouldUpdate=!1,t._removeUpdateListener(r)}}),null!=r?r:[]),void 0!==r){const o=e.useRef(r);a(r,o)||(n.current.state=s(t.getRawState()))}return n.current.state}let c=0;function u(t,e){return e.reduce(((e=t,s)=>e[s]),void 0)}function l(t,e){const s=t.getRawState(),r=[];for(const t of e)r.push(u(s,t));return r}function h(t,s){const[r,n]=e.useState((()=>l(t,s))),o=e.useRef({shouldUpdate:!0,onStoreUpdate:null,currentSubState:null,ordKey:"_"+c++});return o.current.currentSubState=r,null===o.current.onStoreUpdate&&(o.current.onStoreUpdate=function(){o.current.shouldUpdate&&n(l(t,s))},t._addUpdateListenerOpt(o.current.onStoreUpdate,o.current.ordKey,s)),e.useEffect((()=>()=>{o.current.shouldUpdate=!1,t._removeUpdateListenerOpt(o.current.ordKey)}),[]),r}function d(t,s){const r=e.useRef();if(null==r.current&&(r.current=new y(t)),void 0!==s){const n=e.useRef(s);a(s,n)||(r.current=new y(t))}return r.current}const f={storeOrdinal:0,batching:!1,flushStores:{}};s.enablePatches();const p="~._.~";class y{constructor(t){if(this.updateListeners=[],this.ssr=!1,this.reactions=[],this.clientSubscriptions=[],this.reactionCreators=[],this.optimizedUpdateListeners={},this.optimizedUpdateListenerPaths={},this.optimizedListenerPropertyMap={},this._optListenerCount=0,this._patchListeners=[],t instanceof Function){const e=t();this.currentState=e,this.initialState=e,this.createInitialState=t}else this.currentState=t,this.initialState=t,this.createInitialState=()=>t;this.internalOrdId=f.storeOrdinal++}_setInternalOptions({ssr:t,reactionCreators:e=[]}){this.ssr=t,this.reactionCreators=e,this.reactions=e.map((t=>t(this)))}_getReactionCreators(){return this.reactionCreators}_instantiateReactions(){this.reactions=this.reactionCreators.map((t=>t(this)))}_getInitialState(){return this.createInitialState()}_updateStateWithoutReaction(t){this.currentState=t}_updateState(t,e=[]){this.currentState=t,this.batchState=void 0;for(const t of this.reactions)e.push(...t());if(!this.ssr){for(const t of this.clientSubscriptions)t();if(e.length>0){const t=new Set;for(const s of e)if(this.optimizedListenerPropertyMap[s])for(const e of this.optimizedListenerPropertyMap[s])t.add(e);for(const e of t.values())this.optimizedUpdateListeners[e]&&this.optimizedUpdateListeners[e]()}this.updateListeners.forEach((t=>t()))}}_addUpdateListener(t){this.updateListeners.push(t)}_addUpdateListenerOpt(t,e,s){this.optimizedUpdateListeners[e]=t;const r=s.map((t=>t.join(p)));this.optimizedUpdateListenerPaths[e]=r;for(const t of r)null==this.optimizedListenerPropertyMap[t]?this.optimizedListenerPropertyMap[t]=[e]:this.optimizedListenerPropertyMap[t].push(e);this._optListenerCount++}_removeUpdateListener(t){this.updateListeners=this.updateListeners.filter((e=>e!==t))}_removeUpdateListenerOpt(t){const e=this.optimizedUpdateListenerPaths[t];for(const s of e)this.optimizedListenerPropertyMap[s]=this.optimizedListenerPropertyMap[s].filter((e=>e!==t));delete this.optimizedUpdateListenerPaths[t],delete this.optimizedUpdateListeners[t],this._optListenerCount--}listenToPatches(t){return this._patchListeners.push(t),()=>{this._patchListeners=this._patchListeners.filter((e=>e!==t))}}subscribe(t,e){if(!this.ssr){const s=function(t,e,s){let r=e(t.getRawState());return()=>{const n=t.getRawState(),o=e(n);a(o,r)||(s(o,n,r),r=o)}}(this,t,e);return this.clientSubscriptions.push(s),()=>{this.clientSubscriptions=this.clientSubscriptions.filter((t=>t!==s))}}return()=>{console.warn("Pullstate: Subscriptions made on the server side are not registered - so therefor this call to unsubscribe does nothing.")}}createReaction(t,e,{runNow:r=!1,runNowWithSideEffects:n=!1}={}){const o=function(t,e){return r=>{let n=t(r.getRawState());return(o=!1)=>{const i=r.getRawState(),c=t(i);if(o||!a(c,n))if(r._optListenerCount>0){const[t,o,a]=s.produceWithPatches(i,(t=>e(c,t,i,n)));if(r._updateStateWithoutReaction(t),n=c,o.length>0)return r._patchListeners.forEach((t=>t(o,a))),Object.keys(C(o))}else{if(r._patchListeners.length>0){const[t,o,a]=s.produceWithPatches(i,(t=>e(c,t,i,n)));o.length>0&&r._patchListeners.forEach((t=>t(o,a))),r._updateStateWithoutReaction(t)}else r._updateStateWithoutReaction(s.produce(i,(t=>e(c,t,i,n))));n=c}return[]}}}(t,e);this.reactionCreators.push(o);const i=o(this);return this.reactions.push(i),(r||n)&&(i(!0),n&&!this.ssr&&this._updateState(this.currentState)),()=>{this.reactions=this.reactions.filter((t=>t!==i))}}getRawState(){return void 0!==this.batchState?this.batchState:this.currentState}useState(t,e){return i(this,t,e)}useLocalCopyInitial(t){return d(this.createInitialState,t)}useLocalCopySnapshot(t){return d(this.currentState,t)}flushBatch(t=!1){void 0!==this.batchState?this.batchState!==this.currentState&&this._updateState(this.batchState):t||console.error("Pullstate: Trying to flush batch state which was never created or updated on"),this.batchState=void 0}update(t,e){if(f.batching){void 0===this.batchState&&(this.batchState=this.currentState,f.flushStores[this.internalOrdId]=this);const s="function"==typeof t,[r,n,o]=g(this.batchState,t,s);n.length>0&&(this._patchListeners.length>0||e)&&(e&&e(n,o),this._patchListeners.forEach((t=>t(n,o)))),this.batchState=r}else this.batchState=void 0,E(this,t,e)}replace(t){this._updateState(t)}applyPatches(t){!function(t,e){const r=t.getRawState(),n=s.applyPatches(r,e);n!==r&&t._updateState(n,Object.keys(C(e)))}(this,t)}}function C(t,e={}){for(const s of t){let t;for(const r of s.path)t=t?`${t}~._.~${r}`:r,e[t]=1}return e}function g(t,e,r){return r?s.produceWithPatches(t,(s=>e(s,t))):e.reduce((([t,e,r],n)=>{const o=s.produceWithPatches(t,(e=>n(e,t)));return e.push(...o[1]),r.push(...o[2]),[o[0],e,r]}),[t,[],[]])}function E(t,e,r){const n=t.getRawState(),o="function"==typeof e;if(t._optListenerCount>0){const[s,a,i]=g(n,e,o);a.length>0&&(r&&r(a,i),t._patchListeners.forEach((t=>t(a,i))),t._updateState(s,Object.keys(C(a))))}else{let a;if(t._patchListeners.length>0||r){const[s,i,c]=g(n,e,o);i.length>0&&(r&&r(i,c),t._patchListeners.forEach((t=>t(i,c)))),a=s}else a=s.produce(n,(t=>o?e(t,n):e.reduce(((t,e)=>s.produce(t,(s=>e(s,t)))),n)));a!==n&&t._updateState(a)}}var S,_;(S=t.EAsyncEndTags||(t.EAsyncEndTags={})).THREW_ERROR="THREW_ERROR",S.RETURNED_ERROR="RETURNED_ERROR",S.UNFINISHED="UNFINISHED",S.DORMANT="DORMANT",(_=t.EPostActionContext||(t.EPostActionContext={})).WATCH_HIT_CACHE="WATCH_HIT_CACHE",_.BECKON_HIT_CACHE="BECKON_HIT_CACHE",_.RUN_HIT_CACHE="RUN_HIT_CACHE",_.READ_HIT_CACHE="READ_HIT_CACHE",_.READ_RUN="READ_RUN",_.SHORT_CIRCUIT="SHORT_CIRCUIT",_.DIRECT_RUN="DIRECT_RUN",_.BECKON_RUN="BECKON_RUN",_.CACHE_UPDATE="CACHE_UPDATE";const A={listeners:{},results:{},actions:{},actionOrd:{}};let b,k=0;function R(t){if(null===t)return"(n)";const e=typeof t;if("object"!==e){if("undefined"===e)return"(u)";if("string"===e)return":"+t+";";if("boolean"===e||"number"===e)return"("+t+")"}let s="{";for(const e of Object.keys(t).sort())s+=e+R(t[e]);return s+"}"}function m(t){if(A.listeners.hasOwnProperty(t))for(const e of Object.keys(A.listeners[t]))A.listeners[t][e]()}function P(t,e=!0,s=!0){e&&A.actionOrd.hasOwnProperty(t)&&(A.actionOrd[t]+=1),delete A.results[t],s&&m(t)}function O(t,e){return t.actionOrd.hasOwnProperty(e)?t.actionOrd[e]+=1:t.actionOrd[e]=0,t.actionOrd[e]}function w(t=null,e=[],s=""){return{payload:t,tags:e,message:s,error:!1,errorPayload:null}}class v extends Error{constructor(t,e){super(t),this.tags=e}}try{b=new Proxy({},{get:function(t,e){throw new Error(`Pullstate: Trying to access store (${String(e)}) inside async actions without the correct usage or setup.\nIf this error occurred on the server:\n* If using run(), make use of your created instance for this request: instance.runAsyncAction()\n* If using read(), useWatch(), useBeckon() etc. - make sure you have properly set up your <PullstateProvider/>\n\nIf this error occurred on the client:\n* Make sure you have created your "pullstateCore" object with all your stores, using createPullstateCore(), and are making use of instantiate() before rendering.`)}})}catch{b={}}const I=[!0,!1,{message:"",tags:[t.EAsyncEndTags.UNFINISHED],error:!0,payload:null,errorPayload:null},!1,-1];function T(t,e={}){return U((async(e,s,r)=>w(await t(e,s,r))),e)}function U(s,{forceContext:r=!1,shortCircuitHook:i,cacheBreakHook:c,postActionHook:u,subsetKey:l,actionId:h}={}){const d=null!=h?"_"+h:k++,f="undefined"==typeof window;function p(t,e){return null!=e?`${d}-c-${e}`:void 0!==l?`${d}-${R(l(t))}`:`${d}-${R(t)}`}const y="def_wait_"+p({});let C={},g=0;const E={};function S(t,e,s,r){void 0!==u&&u({args:e,result:t,stores:s,context:r})}function _({args:t,cache:e,cacheBreakEnabled:s,context:r,fromListener:n,key:o,postActionEnabled:a,stores:i,customCacheBreak:u}){const l=null!=u?u:c;if(e.results.hasOwnProperty(o)){const c=C.hasOwnProperty(o)&&C[o]>2;if(!f&&!n&&s&&null!=l&&e.results[o][1]&&l({args:t,result:e.results[o][2],stores:i,timeCached:e.results[o][4]})&&!c){C.hasOwnProperty(o)?C[o]++:C[o]=1;const t=e.results[o];return delete e.results[o],{cacheBroke:!0,response:void 0,previous:t}}return c?console.error(`[${o}] Pullstate detected an infinite loop caused by cacheBreakHook()\nreturning true too often (breaking cache as soon as your action is resolving - hence\ncausing beckoned actions to run the action again) in one of your AsyncActions - Pullstate prevented\nfurther looping. Fix in your cacheBreakHook() is needed.`):C[o]=0,a&&e.results[o][1]&&!n&&S(e.results[o][2],t,i,r),{response:e.results[o],cacheBroke:!1,previous:void 0}}return{cacheBroke:!1,response:void 0,previous:void 0}}function T(e,r,n,o,a,i,c,u){return()=>s(n,o,u).then((t=>(a===r.actionOrd[e]&&(i&&S(t,n,o,c),r.results[e]=[!0,!0,t,!1,Date.now()]),t))).catch((s=>{console.error(s);const u={payload:null,errorPayload:null,error:!0,tags:[t.EAsyncEndTags.THREW_ERROR],message:s.message};return a===r.actionOrd[e]&&(i&&S(u,n,o,c),r.results[e]=[!0,!0,u,!1,Date.now()]),u})).then((t=>(a===r.actionOrd[e]&&(delete r.actions[e],f||m(e)),t)))}function U({key:e,cache:s,initiate:r,ssr:n,args:o,stores:a,fromListener:c=!1,postActionEnabled:u=!0,cacheBreakEnabled:l=!0,holdingResult:h,customContext:d,customCacheBreak:p,holdPrevious:y}){const C=_({key:e,cache:s,args:o,stores:a,context:r?t.EPostActionContext.BECKON_HIT_CACHE:t.EPostActionContext.WATCH_HIT_CACHE,postActionEnabled:u,cacheBreakEnabled:l,fromListener:c,customCacheBreak:p});if(C.response)return C.response;if(!s.actions.hasOwnProperty(e)){const c=O(s,e);if(!r){const r=[!1,!1,{message:"",tags:[t.EAsyncEndTags.UNFINISHED],error:!0,payload:null,errorPayload:null},!1,-1];if(f||(s.results[e]=r),y){if(h){const t=[...h];return t[3]=!0,t}if(null!=C.previous){const t=[...C.previous];return t[3]=!0,t}}return r}if(void 0!==i){const r=i({args:o,stores:a});if(!1!==r)return S(r,o,a,t.EPostActionContext.SHORT_CIRCUIT),s.results[e]=[!0,!0,r,!1,Date.now()],s.results[e]}if(!n&&f||(s.actions[e]=T(e,s,o,a,c,u,t.EPostActionContext.BECKON_RUN,d)),f)return I;s.actions[e](),s.results[e]=I}if(y){if(h){const t=[...h];return t[3]=!0,t}if(null!=C.previous){const t=[...C.previous];return t[3]=!0,t}}return I}const B=(s={},{initiate:n=!1,ssr:o=!0,postActionEnabled:i=!1,cacheBreakEnabled:c=!1,holdPrevious:u=!1,dormant:l=!1,key:h,cacheBreak:d}={})=>{const y=e.useRef(),C=e.useRef("."),S=l?".":p(s,h);let _=e.useRef(-1);-1===_.current&&(_.current=g++),l||(E.hasOwnProperty(S)?E[S][_.current]=!0:E[S]={[_.current]:!0});const k=f?e.useContext(L)._asyncCache:A;let R,m;if(f||r){const t=e.useContext(L);R=t.stores,m=t.customContext}else R=x.loaded?x.stores:b;if(!f){const t=()=>{E[S][_.current]&&!a(y.current,k.results[S])&&(y.current=U({key:S,cache:k,initiate:n,ssr:o,args:s,stores:R,fromListener:!0,postActionEnabled:i,cacheBreakEnabled:c,holdingResult:void 0,customContext:m,holdPrevious:u}),O((t=>t+1)))};l||(k.listeners.hasOwnProperty(S)||(k.listeners[S]={}),k.listeners[S][_.current]=t,E[S][_.current]=!0),e.useEffect((()=>(l||(k.listeners[S][_.current]=t,E[S][_.current]=!0),()=>{l||(delete k.listeners[S][_.current],E[S][_.current]=!1)})),[S])}const[P,O]=e.useState(0);return l?(y.current=u&&y.current&&y.current[1]?y.current:[!1,!1,{message:"",tags:[t.EAsyncEndTags.DORMANT],error:!0,payload:null},!1,-1],C.current="."):C.current!==S&&(null!==C.current&&E.hasOwnProperty(C.current)&&(delete k.listeners[C.current][_.current],E[C.current][_.current]=!1),C.current=S,y.current=U({key:S,cache:k,initiate:n,ssr:o,args:s,stores:R,fromListener:!1,postActionEnabled:i,cacheBreakEnabled:c,holdingResult:u&&y.current&&y.current[1]?y.current:void 0,customContext:m,customCacheBreak:"boolean"==typeof d?()=>d:d,holdPrevious:u})),y.current},H=async(e={},s={})=>{const{treatAsUpdate:r=!1,ignoreShortCircuit:n=!1,respectCache:o=!1,key:a,_asyncCache:c=A,_stores:u=(x.loaded?x.stores:b),_customContext:l,cacheBreak:h}=s,d=p(e,a);if(o){const s=_({key:d,cache:c,args:e,stores:u,context:t.EPostActionContext.RUN_HIT_CACHE,postActionEnabled:!0,cacheBreakEnabled:!0,fromListener:!1,customCacheBreak:"boolean"==typeof h?()=>h:h});if(s.response&&s.response[0]){if(!s.response[1]){const t=g++;return c.listeners.hasOwnProperty(d)||(c.listeners[d]={}),new Promise((e=>{c.listeners[d][t]=()=>{const[,s,r]=c.results[d];s&&(delete c.listeners[d][t],e(r))}}))}return s.response[2]}}if(!n&&void 0!==i){const s=i({args:e,stores:u});if(!1!==s)return c.results[d]=[!0,!0,s,!1,Date.now()],S(s,e,u,t.EPostActionContext.SHORT_CIRCUIT),m(d),s}const[,f,y,C,E]=c.results[d]||[!1,!1,{error:!0,message:"",payload:null,tags:[t.EAsyncEndTags.UNFINISHED]},!1,-1];c.results[d]=f&&r?[!0,!0,y,!0,E]:[!0,!1,{error:!0,message:"",payload:null,tags:[t.EAsyncEndTags.UNFINISHED]},!1,-1];let k=O(c,d);return c.actions[d]=T(d,c,e,u,k,!0,t.EPostActionContext.DIRECT_RUN,l),m(d),c.actions[d]()},N=(t={},{key:e,notify:s=!0}={})=>{P(p(t,e),!0,s)},D=(t,s,r)=>{const{notify:n=!0,key:o}=r||{},a=p(t,o);(f?e.useContext(L)._asyncCache:A).results[a]=[!0,!0,s,!1,Date.now()],n&&m(a)},j=(t,e,s)=>D(t,w(e),s),z=(s,r,n)=>{const{notify:a=!0,resetTimeCached:i=!0,runPostActionHook:c=!1,key:u}=n||{},l=p(s,u),h=f?e.useContext(L)._asyncCache:A;if(h.results.hasOwnProperty(l)&&!h.results[l][2].error){const e=h.results[l][2].payload,n={payload:o.default(e,(t=>r(t,e))),error:!1,message:h.results[l][2].message,tags:h.results[l][2].tags};c&&S(n,s,x.loaded?x.stores:b,t.EPostActionContext.CACHE_UPDATE),h.results[l]=[!0,!0,n,h.results[l][3],i?Date.now():h.results[l][4]],a&&m(l)}},W=(s={},r)=>{const{checkCacheBreak:n=!1,key:o}=r||{},a=p(s,o);let i=!1;const u=f?e.useContext(L)._asyncCache:A;if(u.results.hasOwnProperty(a)){if(n&&void 0!==c){const t=f?e.useContext(L).stores:x.loaded?x.stores:b;c({args:s,result:u.results[a][2],stores:t,timeCached:u.results[a][4]})&&(i=!0)}const[t,r,o,l,h]=u.results[a];return{started:t,finished:r,result:o,existed:!0,cacheBreakable:i,updating:l,timeCached:h}}return{started:!1,finished:!1,result:{message:"",tags:[t.EAsyncEndTags.UNFINISHED],error:!0,payload:null,errorPayload:null},updating:!1,existed:!1,cacheBreakable:i,timeCached:-1}};let F;const M=(t={},{initiate:s=!0,ssr:r=!0,postActionEnabled:o,cacheBreakEnabled:a,holdPrevious:i=!1,dormant:c=!1,key:u,onSuccess:l,cacheBreak:h}={})=>{null==o&&(o=s),null==a&&(a=s);const d=B(t,{initiate:s,ssr:r,postActionEnabled:o,cacheBreakEnabled:a,holdPrevious:i,dormant:c,key:u,cacheBreak:h}),[f,p,y,C]=d,g=p&&!y.error,E=p&&y.error;l&&e.useEffect((()=>{g&&!c&&l(y.payload,t)}),[g]);return{isStarted:f,isFinished:p,isUpdating:C,isSuccess:g,isFailure:E,isLoading:f&&(!p||C),endTags:y.tags,error:y.error,payload:y.payload,errorPayload:y.errorPayload,renderPayload:t=>y.error?n.default.Fragment:t(y.payload),message:y.message,raw:d,execute:e=>H(t,e),clearCached:()=>N(t),setCached:(e,s)=>{D(t,e,s)},setCachedPayload:(e,s)=>{j(t,e,s)},updateCached:(e,s)=>{z(t,e,s)}}};return{use:M,useDefer:(t={})=>{const[s,r]=e.useState((()=>({key:t.key?t.key:y,args:{}})));return{...M({},{...t,key:s.key,initiate:!1}),clearCached:()=>{N({},{key:s.key})},unwatchExecuted:()=>{r({key:y,args:{}})},setCached:(t,e={})=>{e.key=s.key,D({},t,e)},setCachedPayload:(t,e={})=>{e.key=s.key,j({},t,e)},updateCached:(t,e={})=>{e.key=s.key,z({},t,e)},execute:(e={},n)=>{var o;const a=null!==(o=t.key)&&void 0!==o?o:p(e);return a!==s.key&&r({key:a,args:e}),H(e,{...n,key:a,cacheBreak:t.cacheBreak}).then((e=>(t.clearOnSuccess&&N({},{key:a}),e)))},args:s.args,key:s.key}},read:(s={},{cacheBreakEnabled:n=!0,postActionEnabled:o=!0,key:a}={})=>{const c=p(s,a),u=f?e.useContext(L)._asyncCache:A;let l,h;if(f||r){const t=e.useContext(L);l=t.stores,h=t.customContext}else l=x.loaded?x.stores:b;const d=_({key:c,cache:u,args:s,stores:l,context:t.EPostActionContext.READ_HIT_CACHE,postActionEnabled:o,cacheBreakEnabled:n,fromListener:!1});if(d.response){if(d.response[2].error)throw new v(d.response[2].message,d.response[2].tags);return d.response[2].payload}if(!u.actions.hasOwnProperty(c)){if(void 0!==i){const e=i({args:s,stores:l});if(!1!==e){if(S(e,s,l,t.EPostActionContext.SHORT_CIRCUIT),u.results[c]=[!0,!0,e,!1,Date.now()],e.error)throw new v(e.message,e.tags);return e.payload}}const e=O(u,c);if(u.actions[c]=T(c,u,s,l,e,o,t.EPostActionContext.READ_RUN,h),f)throw new Error("Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )");throw u.actions[c]()}if(f)throw new Error("Pullstate Async Action: action.read() : Resolve all async state for Suspense actions before Server-side render ( make use of instance.runAsyncAction() )");const y=g++;throw new Promise((t=>{u.listeners[c][y]=()=>{delete u.listeners[c][y],t()}}))},useBeckon:(t={},{ssr:e=!0,postActionEnabled:s=!0,cacheBreakEnabled:r=!0,holdPrevious:n=!1,dormant:o=!1,key:a}={})=>{const i=B(t,{initiate:!0,ssr:e,postActionEnabled:s,cacheBreakEnabled:r,holdPrevious:n,dormant:o,key:a});return[i[1],i[2],i[3]]},useWatch:B,run:H,delayedRun:(t={},{clearOldRun:e=!0,delay:s,immediateIfCached:r=!0,...n})=>{if(e&&clearTimeout(F),r){const{finished:e,cacheBreakable:s}=W(t,{checkCacheBreak:!0});if(e&&!s)return H(t,n),()=>{}}let o={cancelled:!1};return F=setTimeout((()=>{o.cancelled||H(t,n)}),s),()=>{o.cancelled=!0}},clearCache:N,clearAllCache:({notify:t=!0}={})=>{for(const e of Object.keys(A.actionOrd))e.startsWith(d+"-")&&P(e,!0,t)},clearAllUnwatchedCache:({notify:t=!0}={})=>{for(const e of Object.keys(E))Object.values(E[e]).some((t=>t))||(delete E[e],P(e,!1,t))},getCached:W,setCached:D,setCachedPayload:j,updateCached:z}}const L=n.default.createContext(null);let B=null;const x={internalClientStores:!0,loaded:!1,stores:{}};class H{constructor(t,e={}){this.options={},null!==B&&console.error("Pullstate: createPullstate() - Should not be creating the core Pullstate class more than once! In order to re-use pull state, you need to call instantiate() on your already created object."),B=this,x.stores=t,x.loaded=!0,this.options=e}instantiate({hydrateSnapshot:t,ssr:e=!1,customContext:s}={}){if(!e){const e=new N(x.stores,!1,s);return null!=t&&e.hydrateFromSnapshot(t),e.instantiateReactions(),e}const r={};for(const s of Object.keys(x.stores))null==t?r[s]=new y(x.stores[s]._getInitialState()):t.hasOwnProperty(s)?r[s]=new y(t.allState[s]):(r[s]=new y(x.stores[s]._getInitialState()),console.warn(`Pullstate (instantiate): store [${s}] didn't hydrate any state (data was non-existent on hydration object)`)),r[s]._setInternalOptions({ssr:e,reactionCreators:x.stores[s]._getReactionCreators()});return new N(r,!0,s)}useStores(){return D()}useInstance(){return j()}createAsyncActionDirect(t,e={}){return T(t,e)}createAsyncAction(t,e={}){var s;return(null===(s=this.options.asyncActions)||void 0===s?void 0:s.defaultCachingSeconds)&&!e.cacheBreakHook&&(e.cacheBreakHook=t=>t.timeCached<Date.now()-1e3*this.options.asyncActions.defaultCachingSeconds),U(t,e)}}class N{constructor(t,e,s){this._ssr=!1,this._stores={},this._asyncCache={listeners:{},results:{},actions:{},actionOrd:{}},this._stores=t,this._ssr=e,this._customContext=s}getAllUnresolvedAsyncActions(){return Object.keys(this._asyncCache.actions).map((t=>this._asyncCache.actions[t]()))}instantiateReactions(){for(const t of Object.keys(this._stores))this._stores[t]._instantiateReactions()}getPullstateSnapshot(){const t={};for(const e of Object.keys(this._stores))t[e]=this._stores[e].getRawState();return{allState:t,asyncResults:this._asyncCache.results,asyncActionOrd:this._asyncCache.actionOrd}}async resolveAsyncState(){const t=this.getAllUnresolvedAsyncActions();await Promise.all(t)}hasAsyncStateToResolve(){return Object.keys(this._asyncCache.actions).length>0}get stores(){return this._stores}get customContext(){return this._customContext}async runAsyncAction(t,e={},s={}){return this._ssr&&(s._asyncCache=this._asyncCache,s._stores=this._stores,s._customContext=this._customContext),await t.run(e,s)}hydrateFromSnapshot(t){for(const e of Object.keys(this._stores))t.allState.hasOwnProperty(e)?this._stores[e]._updateStateWithoutReaction(t.allState[e]):console.warn(e+" didn't hydrate any state (data was non-existent on hydration object)");A.results=t.asyncResults||{},A.actionOrd=t.asyncActionOrd||{}}}function D(){return e.useContext(L).stores}function j(){return e.useContext(L)}var z;(z=t.EAsyncActionInjectType||(t.EAsyncActionInjectType={})).WATCH="watch",z.BECKON="beckon";const W={};t.InjectAsyncAction=function(e){if(e.type===t.EAsyncActionInjectType.BECKON){const t=e.action.useBeckon(e.args,e.options);return e.children(t)}const s=e.action.useWatch(e.args,e.options);return e.children(s)},t.InjectStoreState=function({store:t,on:e=(t=>t),children:s}){return s(i(t,e))},t.InjectStoreStateOpt=function({store:t,paths:e,children:s}){return s(h(t,e))},t.PullstateContext=L,t.PullstateProvider=({instance:t,children:e})=>n.default.createElement(L.Provider,{value:t},e),t.Store=y,t.batch=function(t){if(f.batching)throw new Error("Pullstate: Can't enact two batch() update functions at the same time-\nmake sure you are not running a batch() inside of a batch() by mistake.");f.batching=!0;try{t()}finally{W.uiBatchFunction?W.uiBatchFunction((()=>{Object.values(f.flushStores).forEach((t=>t.flushBatch(!0)))})):Object.values(f.flushStores).forEach((t=>t.flushBatch(!0))),f.flushStores={},f.batching=!1}},t.createAsyncAction=U,t.createAsyncActionDirect=T,t.createPullstateCore=function(t={},e={}){return new H(t,e)},t.errorResult=function(e=[],s="",r){return{payload:null,tags:[t.EAsyncEndTags.RETURNED_ERROR,...e],message:s,error:!0,errorPayload:r}},t.registerInDevtools=function(t,{namespace:e=""}={}){var s;const r="undefined"!=typeof window?null===(s=window)||void 0===s?void 0:s.__REDUX_DEVTOOLS_EXTENSION__:void 0;if(r)for(const s of Object.keys(t)){const n=t[s],o=r.connect({name:`${e}${s}`});o.init(n.getRawState());let a=!1;n.subscribe((t=>t),(t=>{a?a=!1:o.send("Change",t)})),o.subscribe((t=>{if("DISPATCH"===t.type&&t.state){a=!0;const e=JSON.parse(t.state);n.replace(e)}}))}},t.setupBatch=function({uiBatchFunction:t}){W.uiBatchFunction=t},t.successResult=w,t.update=E,t.useInstance=j,t.useLocalStore=d,t.useStoreState=i,t.useStoreStateOpt=h,t.useStores=D,Object.defineProperty(t,"__esModule",{value:!0})}));
